<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Linuc C 进程线程 (03) | Kyle's Notebook</title><meta name=keywords content="Linux,C"><meta name=description content="来源于多年前记录的笔记"><meta name=author content="kyle"><link rel=canonical href=https://Kyle-Derrick.github.io/zh/posts/tech/c/linux_c_03_%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/><link crossorigin=anonymous href=/assets/css/stylesheet.7d51e19d4bcbbde3c3bab454b80362f047a8942bb44a2f0391c133400340f933.css integrity="sha256-fVHhnUvLvePDurRUuANi8EeolCu0Si8DkcEzQANA+TM=" rel="preload stylesheet" as=style><link rel=icon href=https://Kyle-Derrick.github.io/img/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://Kyle-Derrick.github.io/img/favicon-16x16.ico><link rel=icon type=image/png sizes=32x32 href=https://Kyle-Derrick.github.io/img/favicon-32x32.ico><link rel=apple-touch-icon href=https://Kyle-Derrick.github.io/img/apple-touch-icon.png><link rel=mask-icon href=https://Kyle-Derrick.github.io/img/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://Kyle-Derrick.github.io/zh/posts/tech/c/linux_c_03_%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://Kyle-Derrick.github.io/zh/posts/tech/c/linux_c_03_%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/"><meta property="og:site_name" content="Kyle's Notebook"><meta property="og:title" content="Linuc C 进程线程 (03)"><meta property="og:description" content="来源于多年前记录的笔记"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-07-26T16:19:38+08:00"><meta property="article:modified_time" content="2025-07-26T16:19:38+08:00"><meta property="article:tag" content="Linux"><meta property="article:tag" content="C"><meta name=twitter:card content="summary"><meta name=twitter:title content="Linuc C 进程线程 (03)"><meta name=twitter:description content="来源于多年前记录的笔记"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"文章","item":"https://Kyle-Derrick.github.io/zh/posts/"},{"@type":"ListItem","position":2,"name":"技术类","item":"https://Kyle-Derrick.github.io/zh/posts/tech/"},{"@type":"ListItem","position":3,"name":"C相关","item":"https://Kyle-Derrick.github.io/zh/posts/tech/c/"},{"@type":"ListItem","position":4,"name":"Linuc C 进程线程 (03)","item":"https://Kyle-Derrick.github.io/zh/posts/tech/c/linux_c_03_%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Linuc C 进程线程 (03)","name":"Linuc C 进程线程 (03)","description":"来源于多年前记录的笔记","keywords":["Linux","C"],"articleBody":"Linux C 进程线程 1.基本概念 1.1.程序和进程 程序: 一个可执行文件，不占用系统资源(cpu，内存。。。) 进程: 抽象概念，占用系统资源 程序相当于剧本，进程相当于戏(舞台、演员、灯光。。。) 1.2.并行 来回进行进程间切换达到看似并行的效果(通过硬件手段时钟中断实现) *.程序执行整个过程 1.3.mmu 将虚拟内存地址与物理内存地址关联起来。 设置内存访问级别。(0-3级别，intel) mmu在物理内存上的分配单位是page，也就是4k，即便只需要1k依然分配4k\n不同进程程序用户区内存不会是同一块物理内存，但是内核区都是同一块内存，但是PCB不一样\n1.4.PCB进程控制块(进程描述符) linux内核的进程控制块是task_struct结构体(sched.h) 1.5.环境变量相关 获取整个环境变量表: 先声明变量char **enviton 然后循环，当enviton[i]为NULL时截止 1 2 3 4 5 6 7 8 9 10 11 12 #include extern char **environ; int main() { int i; for (i = 0; environ[i]; i++) { printf(\"%s\\n\", environ[i]); } } getenv #获取指定名的环境变量 setenv #设置环境变量 unsetenv #删除指定名环境变量 2.进程控制 2.1.进程创建 fork函数创建子进程， 返回值大于等于0时表示创建成功，其中，父进程中返回值为大于0的数，子进程中返回值为0 返回值为-1时，创建失败 getpid #获取当前进程pid getppid #获取父进程pid getuid #获取当前进程实际用户id gettuid #获取当前进程有效用户id getgid #获取当前进程使用用户组id getegid #获取当前进程有效用户组id 一定要注意创建子进程后，子进程就会从fork之后开始执行，注意判断子进程并做不同处理，比如循环创建子进程的时候，会出现预料之外的个数的子进程\n若父进程先结束，会出现控制台先回到待输入状态而程序仍在输出的情况\n2.2.进程共享 父子进程共享: 文件描述符(打开文件的结构体) mmap建立的映射区(进程间通信详解) 父子相同处: 全局变量、.data、.text、堆、栈、环境变量、用户id、宿主目录、进程工作目录、信号处理方式… 父子不同处: 进程id、fork返回值、父进程id、进程运行时间、闹钟(定时器)、未决信号集 原则: 读时共享，写时复制\nfork父与子谁先执行由内核调度算法决定。\n2.7.gdb，含子进程的程序 默认gdb跟踪父进程 set follow-fork-mode child #设置在fork之后跟踪子进程 set follow-fork-mode parent #设置跟踪父进程 用if设置断点条件为第几个子进程创建前 3.exec函数族(加载一个进程) 子进程调用exec后，子进程内存所有内容会替换成exec所执行的程序，不再是父进程的副本。进程外壳不变(例如pid) 注意arg参数末尾需要加上一个NULL传入参数，不论是否有其他参数 第二个参数是argv0, 相当于argv的第一个参数 l #list，命令行参数列表(可变参形式) p #会在PATH中查找 e #自己指定环境变量 v #argv会以数组方式传入而不是可变参数 1 2 3 4 5 6 7 8 9 10 11 12 13 #include extern char **environ; int execl( const char *path, const char *arg, ...); int execlp( const char *file, const char *arg, ...); int execle( const char *path, const char *arg , ..., char * const envp[]); int execv( const char *path, char *const argv[]); int execvp( const char *file, char *const argv[]); //如: execlp(\"ls\", \"ls\", \"-l\", \"-a\", NULL); //会在PATH中查找 execl(\"/bin/ls\", \"ls\", \"-l\", \"-a\", NULL); //使用绝对地址，不会查找PATH 4.进程 4.1.孤儿进程和僵尸进程，wait函数 孤儿进程: 父进程比子进程先结束的话，子进程的父进程会变为/sbin/init进程(pid为1)，由init进程进行回收，也就是俗称的进孤儿院。 僵尸进程: 子进程结束了但是父进程并未进行回收，PCB中还有残留 kill命令无法清除僵尸进程，因为僵尸进程已经挂掉了。 僵尸进程在命令行ps的输出中可以看到[名字],表示进程已挂掉但未回收。 插题话: ps输出的状态列中:R表示运行,S表示后台运行,Z表示僵尸进程\nwait: (一次wait只能回收一个子进程，先结束的子进程)(返回-1表示没有子进程) 阻塞等待子进程结束 回收子进程残留资源 获取子进程结束状态 WIFEXITED #非0时表示正常结束 WEXITSTATUS #WIFEXITED为真时此宏为子进程结束返回值 WIFSIGNALED #非0时表示异常终止 WTERMSIG #若上宏为真，此宏获得使进程终止的信号编号 ，比如kill命令的第二个参数(可kill -l查看有哪些信号) WCOREDUMP WIFSTOPPED #非0时表示进程处于暂停状态 WSTOPSIG #若上宏为真，此宏获取使进程暂停的信号编号 WIFCONTINUED #为真时表示进程暂停后已经继续运行 waitpid 作用同于wait 可以清理指定pid进程 可以不阻塞(不阻塞时，返回0表示没有回收，子进程正在运行) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include #include /* pid \u003e 0 回收指定进程 =-1 回收任意进程(相当于wait) =0 回收和当前调用waitpid一个组的所有子进程 \u003c-1 回收指定进程组内的任意子进程 option WNOHANG 非阻塞 WNOHANG return immediately if no child has exited. WUNTRACED also return if a child has stopped (but not traced via ptrace(2)). Status for traced children which have stopped is provided even if this option is not specified. WCONTINUED (since Linux 2.6.10) also return if a stopped child has been resumed by delivery of SIGCONT. */ pid_t waitpid(pid_t pid, int *wstatus, int options); 4.2.IPC进程间通信 管道(最简单) pipe(管道一般读写行为) fifo(非血缘关系进程间通信) 信号(开销最小) 共享映射区(无血缘关系) mmap(非血缘关系进程间通信) 本地套接字(最稳定) 4.2.1.管道(匿名管道) 其本质是一个伪文件(实为内核缓冲区，队列) 由两个文件描述符引用，一个读一个写 规定从写端流入，读端流出 局限性 不能自己读自己写 数据一旦被读走就不存在了，不可反复读取 半双工通信方式，数据只能在一个方向上流动 只能在有公共祖先的进程间使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include /* On Alpha, IA-64, MIPS, SuperH, and SPARC/SPARC64; see NOTES */ struct fd_pair { long fd[2]; }; struct fd_pair pipe(); /* On all other architectures */ int pipe(int pipefd[2]); #define _GNU_SOURCE /* See feature_test_macros(7) */ #include /* Obtain O_* constant definitions */ #include int pipe2(int pipefd[2], int flags); //正常0, 异常-1 //数组中0为可读的，1为可写的 4.2.2.fifo非血缘管道(命名管道) 可以同时多端读多端写 1 2 3 4 5 6 7 8 9 10 11 12 #include #include int mkfifo(const char *pathname, mode_t mode); /* Definition of AT_* constants */ #include #include int mkfifoat(int dirfd, const char *pathname, mode_t mode); //然后用open打开即可 4.2.3.mmap共享内存映射 创建映射区过程中隐含了一次文件读取操作，所以需要读取权限 映射区权限需要小于或者等于文件权限，标志无所谓 文件关闭对已创建的映射区无影响，映射区创建后即可关闭文件 映射区大小不能为0，所以用于映射的文件必须有实际大小，mmap总线错误一般都是共享文件储存大小引起的 munmap传入的指针地址一定是mmap返回的地址 文件偏移量必须是4K的整数倍，因为一页就相当于4K mmap出错概率很高，需要仔细检查返回值 利用mmap进行父子通信时，MAP_SHARED可以正常工作，MAP_PRICATE则不行，相当于映射区私有不共享。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset); int munmap(void *addr, size_t length); //关闭映射区 /* 若addr为NULL，则内核自动分配 prot为权限，读，写，执行 flags设置映射区修改是否反映到物理磁盘上 MAP_SHARED #会反映到物理磁盘上 MAP_PRIVATE #不会反映到无力磁盘上 offset文件的偏移量(4K的整数倍) 返回值: 成功: 返回创建映射区的首地址 失败: 返回MAP_FAILED宏 详情查看man文档 */ 4.2.4.mmap匿名映射区 使用宏MAP_ANONYMOUS(或MAP_ANON) 1 2 //大小随意 int *p = mmap(NULL,4,PROT_READ|PROT_WRITE,MAP_SHARED|MAP_ANONYMOUS,-1,0); 4.2.5.mmap非血缘进程通信 mmap指向同一个文件，并且shared即可 可多端读多端写 4.2.6.用文件进行进程间通信 同理 5.信号 5.1.信号基本概念 简单 #只能带一个简单标志 不占内存 #用或不用信号都是一样内存占用 信号是由软件方式实现的(软中断)，所以其具有很强的延时性，但对于用户来说不易察觉 每个进程收到的信号都是由内核负责发送的，内核处理 ","wordCount":"3017","inLanguage":"zh","datePublished":"2025-07-26T16:19:38+08:00","dateModified":"2025-07-26T16:19:38+08:00","author":[{"@type":"Person","name":"kyle"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://Kyle-Derrick.github.io/zh/posts/tech/c/linux_c_03_%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/"},"publisher":{"@type":"Organization","name":"Kyle's Notebook","logo":{"@type":"ImageObject","url":"https://Kyle-Derrick.github.io/img/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://Kyle-Derrick.github.io/zh/ accesskey=h title="Kyle's Notebook (Alt + H)">Kyle's Notebook</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://Kyle-Derrick.github.io/zh/search title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://Kyle-Derrick.github.io/zh/ title=主页><span>主页</span></a></li><li><a href=https://Kyle-Derrick.github.io/zh/posts title=文章><span>文章</span></a></li><li><a href=https://Kyle-Derrick.github.io/zh/archives title=时间轴><span>时间轴</span></a></li><li><a href=https://Kyle-Derrick.github.io/zh/tags title=标签><span>标签</span></a></li><li><a href=https://Kyle-Derrick.github.io/zh/about title=关于><span>关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://Kyle-Derrick.github.io/zh/>主页</a>&nbsp;»&nbsp;<a href=https://Kyle-Derrick.github.io/zh/posts/>文章</a>&nbsp;»&nbsp;<a href=https://Kyle-Derrick.github.io/zh/posts/tech/>技术类</a>&nbsp;»&nbsp;<a href=https://Kyle-Derrick.github.io/zh/posts/tech/c/>C相关</a>&nbsp;»&nbsp;<span class=breadcrumbs-current>Linuc C 进程线程 (03)</span></div><aside class=post-toc><span class=title>全部文章</span>
<dev class=post-toc-tree><details open><summary class=summary-active accesskey=c title="(Alt + C)"><a href=/zh/posts/tech/ class=node-active>技术类</a></summary><dev class=sub-tree><details open><summary class=summary-active accesskey=c title="(Alt + C)"><a href=/zh/posts/tech/c/ class=node-active>C相关</a></summary><dev class=sub-tree><a href=/zh/posts/tech/c/cmake%E5%9F%BA%E7%A1%80/ class=tree-node>CMake 基础</a>
<a href=/zh/posts/tech/c/linux_c_01_%E5%9F%BA%E7%A1%80/ class=tree-node>Linuc C 基础 (01)</a>
<a href=/zh/posts/tech/c/linux_c_02_%E5%9F%BA%E7%A1%80%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0/ class=tree-node>Linuc C 基础系统函数 (02)</a>
<a href=/zh/posts/tech/c/linux_c_03_%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/ class="tree-node node-active">Linuc C 进程线程 (03)</a></dev></details><details><summary accesskey=c title="(Alt + C)"><a href=/zh/posts/tech/open_source_favorites/>开源收藏夹</a></summary><dev class=sub-tree><a href=/zh/posts/tech/open_source_favorites/%E4%BA%92%E8%81%94barrier/ class=tree-node>互联Barrier安装记录</a>
<a href=/zh/posts/tech/open_source_favorites/open_source_lib/ class=tree-node>开源库搜寻记录</a></dev></details><details><summary accesskey=c title="(Alt + C)"><a href=/zh/posts/tech/system_level/>系统层面相关</a></summary><dev class=sub-tree><a href=/zh/posts/tech/system_level/%E5%86%85%E5%AD%98%E7%BC%93%E5%86%B2%E5%8C%BA%E4%BC%AA%E8%A3%85%E6%96%87%E4%BB%B6%E6%B5%81/ class=tree-node>如何将内存缓冲区伪装成文件流</a></dev></details><details><summary accesskey=c title="(Alt + C)"><a href=/zh/posts/tech/linux/>Linux相关</a></summary><dev class=sub-tree><a href=/zh/posts/tech/linux/esxi7%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%85%8B%E9%9A%86%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%8E%B0/ class=tree-node>ESXi7虚拟机克隆脚本实现</a>
<a href=/zh/posts/tech/linux/ubuntu%E6%B8%85%E5%8D%8E%E6%BA%90/ class=tree-node>Ubuntu清华源配置</a>
<a href=/zh/posts/tech/linux/%E5%8F%8C%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4%E9%97%AE%E9%A2%98/ class=tree-node>双系统时间问题</a>
<a href=/zh/posts/tech/linux/linux%E4%BD%9C%E4%B8%BA%E7%BD%91%E5%85%B3%E6%8F%90%E4%BE%9B%E8%B7%AF%E7%94%B1/ class=tree-node>linux作为网关提供路由</a>
<a href=/zh/posts/tech/linux/ipsec_ikev2%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2/ class=tree-node>IPsec/IKEv2服务部署</a>
<a href=/zh/posts/tech/linux/wireguard%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2/ class=tree-node>WireGuard服务部署</a>
<a href=/zh/posts/tech/linux/smb%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2/ class=tree-node>SMB服务部署</a>
<a href=/zh/posts/tech/linux/centos7%E6%9C%80%E5%B0%8F%E5%AE%89%E8%A3%85%E5%90%8E%E9%85%8D%E7%BD%AE/ class=tree-node>CentOS7最小安装后配置</a>
<a href=/zh/posts/tech/linux/centos7%E4%BD%BF%E7%94%A8%E9%AB%98%E7%89%88%E6%9C%ACgcc/ class=tree-node>CentOS7 使用高版本gcc</a>
<a href=/zh/posts/tech/linux/centos7_nodejs%E5%AE%89%E8%A3%85/ class=tree-node>CentOS7 上安装 NodeJs</a></dev></details><details><summary accesskey=c title="(Alt + C)"><a href=/zh/posts/tech/network/>网络相关</a></summary><dev class=sub-tree><details><summary accesskey=c title="(Alt + C)"><a href=/zh/posts/tech/network/vpn/>VPN相关</a></summary><dev class=sub-tree><details><summary accesskey=c title="(Alt + C)"><a href=/zh/posts/tech/network/vpn/ipsec/>IPsec VPN相关</a></summary><dev class=sub-tree><a href=/zh/posts/tech/network/vpn/ipsec/strongswan%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/ class=tree-node>StrongSwan安装部署（CentOS7 为例）</a>
<a href=/zh/posts/tech/network/vpn/ipsec/ipsec%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/ class=tree-node>IPsec技术原理</a></dev></details></dev></details><details><summary accesskey=c title="(Alt + C)"><a href=/zh/posts/tech/network/knowledge/>网络相关知识点</a></summary><dev class=sub-tree><a href=/zh/posts/tech/network/knowledge/udp%E6%89%93%E6%B4%9E%E5%8E%9F%E7%90%86%E5%8F%8A%E6%B5%81%E7%A8%8B/ class=tree-node>UDP打洞原理及流程</a></dev></details></dev></details><details><summary accesskey=c title="(Alt + C)"><a href=/zh/posts/tech/plan/>学习或研究计划</a></summary><dev class=sub-tree><a href=/zh/posts/tech/plan/%E6%BA%90%E7%A0%81%E7%A0%94%E7%A9%B6%E8%AE%A1%E5%88%92/ class=tree-node>源码研究计划（源于AI推荐）</a></dev></details><details><summary accesskey=c title="(Alt + C)"><a href=/zh/posts/tech/rust/>Rust相关</a></summary><dev class=sub-tree><a href=/zh/posts/tech/rust/%E8%AE%B0%E5%BD%95%E7%82%B9/ class=tree-node>Rust杂项记录点</a>
<a href=/zh/posts/tech/rust/%E5%9B%BD%E5%86%85%E6%BA%90%E5%AE%89%E8%A3%85/ class=tree-node>Rust国内源安装</a>
<a href=/zh/posts/tech/rust/%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E5%8F%8A%E7%A6%BB%E7%BA%BF%E4%BE%9D%E8%B5%96/ class=tree-node>Rust离线环境安装及使用vendor离线编译项目</a></dev></details><details><summary accesskey=c title="(Alt + C)"><a href=/zh/posts/tech/open_source_component/>开源组件</a></summary><dev class=sub-tree><details><summary accesskey=c title="(Alt + C)"><a href=/zh/posts/tech/open_source_component/java_web_base/>Java Web 基本框架相关</a></summary><dev class=sub-tree></dev></details><details><summary accesskey=c title="(Alt + C)"><a href=/zh/posts/tech/open_source_component/redis/>Redis相关</a></summary><dev class=sub-tree><a href=/zh/posts/tech/open_source_component/redis/redis%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/ class=tree-node>Redis基本命令</a>
<a href=/zh/posts/tech/open_source_component/redis/redis_concurrency_case/ class=tree-node>Redis并发相关使用案例</a></dev></details></dev></details><details><summary accesskey=c title="(Alt + C)"><a href=/zh/posts/tech/java/>Java相关</a></summary><dev class=sub-tree><a href=/zh/posts/tech/java/maven_gradle_mirror/ class=tree-node>Maven、Gradle国内源配置</a></dev></details><details><summary accesskey=c title="(Alt + C)"><a href=/zh/posts/tech/other_general/>其他通用</a></summary><dev class=sub-tree><details><summary accesskey=c title="(Alt + C)"><a href=/zh/posts/tech/other_general/hugo/>hugo</a></summary><dev class=sub-tree><a href=/zh/posts/tech/other_general/hugo/hugo_include_image/ class=tree-node>hugo从同级目录下插入图片（相对路径）</a>
<a href=/zh/posts/tech/other_general/hugo/hugo_exp_note/ class=tree-node>hugo使用经验</a>
<a href=/zh/posts/tech/other_general/hugo/hugo_giscus_comment/ class=tree-node>hugo使用Giscus支持评论</a>
<a href=/zh/posts/tech/other_general/hugo/hugo_and_github_pages/ class=tree-node>Hugo使用PaperMod主题搭建博客，并配置自动发布Github Pages</a></dev></details></dev></details><details><summary accesskey=c title="(Alt + C)"><a href=/zh/posts/tech/vscode/>vs-code相关</a></summary><dev class=sub-tree><a href=/zh/posts/tech/vscode/vscode-project-config/ class=tree-node>vscode项目级配置</a></dev></details></dev></details><details><summary accesskey=c title="(Alt + C)"><a href=/zh/posts/life/>生活类</a></summary><dev class=sub-tree></dev></details><details><summary accesskey=c title="(Alt + C)"><a href=/zh/posts/read/>阅读类</a></summary><dev class=sub-tree></dev></details></dev></aside><hr><h1 class="post-title entry-hint-parent">Linuc C 进程线程 (03)</h1><div class=post-description>来源于多年前记录的笔记</div><div class=post-meta><span title='2025-07-26 16:19:38 +0800 +0800'>2025-07-26</span>&nbsp;·&nbsp;7 分钟&nbsp;·&nbsp;kyle</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#linux-c-%e8%bf%9b%e7%a8%8b%e7%ba%bf%e7%a8%8b aria-label="Linux C 进程线程">Linux C 进程线程</a><ul><li><a href=#1%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5 aria-label=1.基本概念>1.基本概念</a><ul><li><a href=#11%e7%a8%8b%e5%ba%8f%e5%92%8c%e8%bf%9b%e7%a8%8b aria-label=1.1.程序和进程>1.1.程序和进程</a></li><li><a href=#12%e5%b9%b6%e8%a1%8c aria-label=1.2.并行>1.2.并行</a></li><li><a href=#%e7%a8%8b%e5%ba%8f%e6%89%a7%e8%a1%8c%e6%95%b4%e4%b8%aa%e8%bf%87%e7%a8%8b aria-label=*.程序执行整个过程>*.程序执行整个过程</a></li><li><a href=#13mmu aria-label=1.3.mmu>1.3.mmu</a></li><li><a href=#14pcb%e8%bf%9b%e7%a8%8b%e6%8e%a7%e5%88%b6%e5%9d%97%e8%bf%9b%e7%a8%8b%e6%8f%8f%e8%bf%b0%e7%ac%a6 aria-label=1.4.PCB进程控制块(进程描述符)>1.4.PCB进程控制块(进程描述符)</a></li><li><a href=#15%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f%e7%9b%b8%e5%85%b3 aria-label=1.5.环境变量相关>1.5.环境变量相关</a></li></ul></li><li><a href=#2%e8%bf%9b%e7%a8%8b%e6%8e%a7%e5%88%b6 aria-label=2.进程控制>2.进程控制</a><ul><li><a href=#21%e8%bf%9b%e7%a8%8b%e5%88%9b%e5%bb%ba aria-label=2.1.进程创建>2.1.进程创建</a></li><li><a href=#22%e8%bf%9b%e7%a8%8b%e5%85%b1%e4%ba%ab aria-label=2.2.进程共享>2.2.进程共享</a></li><li><a href=#27gdb%e5%90%ab%e5%ad%90%e8%bf%9b%e7%a8%8b%e7%9a%84%e7%a8%8b%e5%ba%8f aria-label=2.7.gdb，含子进程的程序>2.7.gdb，含子进程的程序</a></li></ul></li><li><a href=#3exec%e5%87%bd%e6%95%b0%e6%97%8f%e5%8a%a0%e8%bd%bd%e4%b8%80%e4%b8%aa%e8%bf%9b%e7%a8%8b aria-label=3.exec函数族(加载一个进程)>3.exec函数族(加载一个进程)</a></li><li><a href=#4%e8%bf%9b%e7%a8%8b aria-label=4.进程>4.进程</a><ul><li><a href=#41%e5%ad%a4%e5%84%bf%e8%bf%9b%e7%a8%8b%e5%92%8c%e5%83%b5%e5%b0%b8%e8%bf%9b%e7%a8%8bwait%e5%87%bd%e6%95%b0 aria-label=4.1.孤儿进程和僵尸进程，wait函数>4.1.孤儿进程和僵尸进程，wait函数</a></li><li><a href=#42ipc%e8%bf%9b%e7%a8%8b%e9%97%b4%e9%80%9a%e4%bf%a1 aria-label=4.2.IPC进程间通信>4.2.IPC进程间通信</a><ul><li><a href=#421%e7%ae%a1%e9%81%93%e5%8c%bf%e5%90%8d%e7%ae%a1%e9%81%93 aria-label=4.2.1.管道(匿名管道)>4.2.1.管道(匿名管道)</a></li><li><a href=#422fifo%e9%9d%9e%e8%a1%80%e7%bc%98%e7%ae%a1%e9%81%93%e5%91%bd%e5%90%8d%e7%ae%a1%e9%81%93 aria-label=4.2.2.fifo非血缘管道(命名管道)>4.2.2.fifo非血缘管道(命名管道)</a></li><li><a href=#423mmap%e5%85%b1%e4%ba%ab%e5%86%85%e5%ad%98%e6%98%a0%e5%b0%84 aria-label=4.2.3.mmap共享内存映射>4.2.3.mmap共享内存映射</a></li><li><a href=#424mmap%e5%8c%bf%e5%90%8d%e6%98%a0%e5%b0%84%e5%8c%ba aria-label=4.2.4.mmap匿名映射区>4.2.4.mmap匿名映射区</a></li><li><a href=#425mmap%e9%9d%9e%e8%a1%80%e7%bc%98%e8%bf%9b%e7%a8%8b%e9%80%9a%e4%bf%a1 aria-label=4.2.5.mmap非血缘进程通信>4.2.5.mmap非血缘进程通信</a></li><li><a href=#426%e7%94%a8%e6%96%87%e4%bb%b6%e8%bf%9b%e8%a1%8c%e8%bf%9b%e7%a8%8b%e9%97%b4%e9%80%9a%e4%bf%a1 aria-label=4.2.6.用文件进行进程间通信>4.2.6.用文件进行进程间通信</a></li></ul></li><li><a href=#5%e4%bf%a1%e5%8f%b7 aria-label=5.信号>5.信号</a><ul><li><a href=#51%e4%bf%a1%e5%8f%b7%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5 aria-label=5.1.信号基本概念>5.1.信号基本概念</a></li></ul></li></ul></li></ul></li></ul></div></details></div><script>document.addEventListener("DOMContentLoaded",function(){const n=document.querySelectorAll(".toc a"),i=Array.from(n).map(e=>{const t=e.getAttribute("href").substring(1);return document.getElementById(decodeURI(t))});let e=[];function s(){if(window.innerWidth<1280){e.length>0&&(e.forEach(e=>e.classList.remove("toc-active")),e=[]);return}const t=window.scrollY;i.forEach((s,o)=>{if(!s)return;const r=s.offsetTop,l=s.offsetHeight,a=i[o+1],c=a?a.offsetTop:1/0;t>=r&&t<c&&(e.forEach(e=>e.classList.remove("toc-active")),e=[],n[o].classList.add("toc-active"),e.push(n[o]))})}var o=document.querySelector(".toc"),t=document.querySelector(".toc details");function a(){window.innerWidth>=1280&&o.classList.contains("toc-closed")&&t.removeAttribute("open"),s()}window.addEventListener("resize",a),t&&t.addEventListener("toggle",function(){if(window.innerWidth<1280)return;t.open?o.classList.remove("toc-closed"):o.classList.add("toc-closed")}),window.addEventListener("scroll",s),s()})</script><div class=post-content><h1 id=linux-c-进程线程>Linux C 进程线程<a hidden class=anchor aria-hidden=true href=#linux-c-进程线程>#</a></h1><h2 id=1基本概念>1.基本概念<a hidden class=anchor aria-hidden=true href=#1基本概念>#</a></h2><h3 id=11程序和进程>1.1.程序和进程<a hidden class=anchor aria-hidden=true href=#11程序和进程>#</a></h3><ul><li>程序: 一个可执行文件，不占用系统资源(cpu，内存。。。)</li><li>进程: 抽象概念，占用系统资源</li><li>程序相当于剧本，进程相当于戏(舞台、演员、灯光。。。)</li></ul><h3 id=12并行>1.2.并行<a hidden class=anchor aria-hidden=true href=#12并行>#</a></h3><ul><li>来回进行进程间切换达到看似并行的效果(通过硬件手段时钟中断实现)</li></ul><h3 id=程序执行整个过程>*.程序执行整个过程<a hidden class=anchor aria-hidden=true href=#程序执行整个过程>#</a></h3><p><img alt=008 loading=lazy src=../img/008.jpg></p><h3 id=13mmu>1.3.mmu<a hidden class=anchor aria-hidden=true href=#13mmu>#</a></h3><p><img alt=009 loading=lazy src=../img/009.jpg></p><ul><li>将虚拟内存地址与物理内存地址关联起来。</li><li>设置内存访问级别。(0-3级别，intel)</li></ul><blockquote><p>mmu在物理内存上的分配单位是page，也就是4k，即便只需要1k依然分配4k</p><p>不同进程程序用户区内存不会是同一块物理内存，但是<strong>内核区都是同一块内存</strong>，但是<strong>PCB不一样</strong></p></blockquote><p><img alt=010 loading=lazy src=../img/010.jpg></p><h3 id=14pcb进程控制块进程描述符>1.4.PCB进程控制块(进程描述符)<a hidden class=anchor aria-hidden=true href=#14pcb进程控制块进程描述符>#</a></h3><ul><li>linux内核的进程控制块是task_struct结构体(sched.h)
<img alt=011 loading=lazy src=../img/011.jpg></li></ul><h3 id=15环境变量相关>1.5.环境变量相关<a hidden class=anchor aria-hidden=true href=#15环境变量相关>#</a></h3><ul><li>获取整个环境变量表:</li><li><ul><li>先声明变量char **enviton</li></ul></li><li><ul><li>然后循环，当enviton[i]为NULL时截止</li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>extern</span> <span class=kt>char</span> <span class=o>**</span><span class=n>environ</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>environ</span><span class=p>[</span><span class=n>i</span><span class=p>];</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>environ</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>getenv #获取指定名的环境变量</li><li>setenv #设置环境变量</li><li>unsetenv #删除指定名环境变量</li></ul><h2 id=2进程控制>2.进程控制<a hidden class=anchor aria-hidden=true href=#2进程控制>#</a></h2><h3 id=21进程创建>2.1.进程创建<a hidden class=anchor aria-hidden=true href=#21进程创建>#</a></h3><ul><li>fork函数创建子进程，</li><li><ol><li>返回值大于等于0时表示创建成功，其中，父进程中返回值为大于0的数，子进程中返回值为0</li></ol></li><li><ol start=2><li>返回值为-1时，创建失败</li></ol></li><li>getpid #获取当前进程pid</li><li>getppid #获取父进程pid</li><li>getuid #获取当前进程实际用户id</li><li>gettuid #获取当前进程有效用户id</li><li>getgid #获取当前进程使用用户组id</li><li>getegid #获取当前进程有效用户组id</li></ul><blockquote><p>一定要注意创建子进程后，子进程就会从fork之后开始执行，<strong>注意判断子进程并做不同处理</strong>，比如循环创建子进程的时候，会出现预料之外的个数的子进程</p><p>若父进程先结束，会出现控制台先回到待输入状态而程序仍在输出的情况</p></blockquote><h3 id=22进程共享>2.2.进程共享<a hidden class=anchor aria-hidden=true href=#22进程共享>#</a></h3><ul><li>父子进程共享:</li><li><ol><li>文件描述符(打开文件的结构体)</li></ol></li><li><ol start=2><li>mmap建立的映射区(进程间通信详解)</li></ol></li><li>父子相同处: 全局变量、.data、.text、堆、栈、环境变量、用户id、宿主目录、进程工作目录、信号处理方式&mldr;</li><li>父子不同处: 进程id、fork返回值、父进程id、进程运行时间、闹钟(定时器)、未决信号集</li></ul><blockquote><p>原则: 读时共享，写时复制</p><p>fork父与子谁先执行由内核调度算法决定。</p></blockquote><h3 id=27gdb含子进程的程序>2.7.gdb，含子进程的程序<a hidden class=anchor aria-hidden=true href=#27gdb含子进程的程序>#</a></h3><ul><li>默认gdb跟踪父进程</li><li>set follow-fork-mode child #设置在fork之后跟踪子进程</li><li>set follow-fork-mode parent #设置跟踪父进程</li><li>用if设置断点条件为第几个子进程创建前</li></ul><h2 id=3exec函数族加载一个进程>3.exec函数族(加载一个进程)<a hidden class=anchor aria-hidden=true href=#3exec函数族加载一个进程>#</a></h2><ul><li>子进程调用exec后，子进程内存所有内容会替换成exec所执行的程序，不再是父进程的副本。进程外壳不变(例如pid)</li><li>注意arg参数末尾需要加上一个NULL传入参数，不论是否有其他参数</li><li>第二个参数是argv0, 相当于argv的第一个参数</li><li><ul><li>l #list，命令行参数列表(可变参形式)</li></ul></li><li><ul><li>p #会在PATH中查找</li></ul></li><li><ul><li>e #自己指定环境变量</li></ul></li><li><ul><li>v #argv会以数组方式传入而不是可变参数</li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>extern</span> <span class=kt>char</span> <span class=o>**</span><span class=n>environ</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>execl</span><span class=p>(</span> <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>path</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>arg</span><span class=p>,</span> <span class=p>...);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>execlp</span><span class=p>(</span> <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>file</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>arg</span><span class=p>,</span> <span class=p>...);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>execle</span><span class=p>(</span> <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>path</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>arg</span> <span class=p>,</span> <span class=p>...,</span> <span class=kt>char</span> <span class=o>*</span> <span class=k>const</span> <span class=n>envp</span><span class=p>[]);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>execv</span><span class=p>(</span> <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>path</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=k>const</span> <span class=n>argv</span><span class=p>[]);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>execvp</span><span class=p>(</span> <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>file</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=k>const</span> <span class=n>argv</span><span class=p>[]);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//如: 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>execlp</span><span class=p>(</span><span class=s>&#34;ls&#34;</span><span class=p>,</span> <span class=s>&#34;ls&#34;</span><span class=p>,</span> <span class=s>&#34;-l&#34;</span><span class=p>,</span> <span class=s>&#34;-a&#34;</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>   <span class=c1>//会在PATH中查找
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>execl</span><span class=p>(</span><span class=s>&#34;/bin/ls&#34;</span><span class=p>,</span> <span class=s>&#34;ls&#34;</span><span class=p>,</span> <span class=s>&#34;-l&#34;</span><span class=p>,</span> <span class=s>&#34;-a&#34;</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>   <span class=c1>//使用绝对地址，不会查找PATH
</span></span></span></code></pre></td></tr></table></div></div><h2 id=4进程>4.进程<a hidden class=anchor aria-hidden=true href=#4进程>#</a></h2><h3 id=41孤儿进程和僵尸进程wait函数>4.1.孤儿进程和僵尸进程，wait函数<a hidden class=anchor aria-hidden=true href=#41孤儿进程和僵尸进程wait函数>#</a></h3><ul><li>孤儿进程:</li><li><ul><li>父进程比子进程先结束的话，子进程的父进程会变为/sbin/init进程(pid为1)，由init进程进行回收，也就是俗称的进孤儿院。</li></ul></li><li>僵尸进程:</li><li><ul><li>子进程结束了但是父进程并未进行回收，PCB中还有残留</li></ul></li><li><ul><li>kill命令无法清除僵尸进程，因为僵尸进程已经挂掉了。</li></ul></li></ul><blockquote><p>僵尸进程在命令行ps的输出中可以看到[名字]&lt;defunct>,表示进程已挂掉但未回收。
插题话: ps输出的状态列中:R表示运行,S表示后台运行,Z表示僵尸进程</p></blockquote><ul><li>wait: (一次wait只能回收一个子进程，先结束的子进程)(返回-1表示没有子进程)</li><li><ol><li>阻塞等待子进程结束</li></ol></li><li><ol start=2><li>回收子进程残留资源</li></ol></li><li><ol start=3><li>获取子进程结束状态</li></ol></li><li><ul><li>WIFEXITED #非0时表示正常结束</li></ul></li><li><ul><li>WEXITSTATUS #WIFEXITED为真时此宏为子进程结束返回值</li></ul></li><li><ul><li>WIFSIGNALED #非0时表示异常终止</li></ul></li><li><ul><li>WTERMSIG #若上宏为真，此宏获得使进程终止的信号编号 ，比如kill命令的第二个参数(可kill -l查看有哪些信号)</li></ul></li><li><ul><li>WCOREDUMP</li></ul></li><li><ul><li>WIFSTOPPED #非0时表示进程处于暂停状态</li></ul></li><li><ul><li>WSTOPSIG #若上宏为真，此宏获取使进程暂停的信号编号</li></ul></li><li><ul><li>WIFCONTINUED #为真时表示进程暂停后已经继续运行</li></ul></li><li>waitpid</li><li><ol><li>作用同于wait</li></ol></li><li><ol start=2><li>可以清理指定pid进程</li></ol></li><li><ol start=3><li>可以不阻塞(不阻塞时，返回0表示没有回收，子进程正在运行)</li></ol></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/types.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/wait.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>pid &gt; 0 回收指定进程
</span></span></span><span class=line><span class=cl><span class=cm>=-1 回收任意进程(相当于wait)
</span></span></span><span class=line><span class=cl><span class=cm>=0  回收和当前调用waitpid一个组的所有子进程
</span></span></span><span class=line><span class=cl><span class=cm>&lt;-1 回收指定进程组内的任意子进程
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>option
</span></span></span><span class=line><span class=cl><span class=cm>WNOHANG 非阻塞
</span></span></span><span class=line><span class=cl><span class=cm>WNOHANG     return immediately if no child has exited.
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>WUNTRACED   also return if a child has stopped (but not traced via ptrace(2)).   Status  for  traced  children which have stopped is provided even if this option is not specified.
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>WCONTINUED (since Linux 2.6.10) also return if a stopped child has been resumed by delivery of SIGCONT.
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl><span class=kt>pid_t</span> <span class=nf>waitpid</span><span class=p>(</span><span class=kt>pid_t</span> <span class=n>pid</span><span class=p>,</span> <span class=kt>int</span> <span class=o>*</span><span class=n>wstatus</span><span class=p>,</span> <span class=kt>int</span> <span class=n>options</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=42ipc进程间通信>4.2.IPC进程间通信<a hidden class=anchor aria-hidden=true href=#42ipc进程间通信>#</a></h3><ol><li>管道(最简单)</li></ol><ul><li>pipe(管道一般读写行为)</li><li>fifo(非血缘关系进程间通信)</li></ul><ol start=2><li>信号(开销最小)</li><li>共享映射区(无血缘关系)</li></ol><ul><li>mmap(非血缘关系进程间通信)</li></ul><ol start=4><li>本地套接字(最稳定)</li></ol><h4 id=421管道匿名管道>4.2.1.管道(匿名管道)<a hidden class=anchor aria-hidden=true href=#421管道匿名管道>#</a></h4><ol><li>其本质是一个伪文件(实为内核缓冲区，队列)</li><li>由两个文件描述符引用，一个读一个写</li><li>规定从写端流入，读端流出</li></ol><ul><li>局限性</li></ul><ol><li>不能自己读自己写</li><li>数据一旦被读走就不存在了，不可反复读取</li><li>半双工通信方式，数据只能在一个方向上流动</li><li>只能在有公共祖先的进程间使用</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cm>/* On Alpha, IA-64, MIPS, SuperH, and SPARC/SPARC64; see NOTES */</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>fd_pair</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>long</span> <span class=n>fd</span><span class=p>[</span><span class=mi>2</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>fd_pair</span> <span class=nf>pipe</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* On all other architectures */</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>pipe</span><span class=p>(</span><span class=kt>int</span> <span class=n>pipefd</span><span class=p>[</span><span class=mi>2</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#define _GNU_SOURCE             </span><span class=cm>/* See feature_test_macros(7) */</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;fcntl.h&gt;              /* Obtain O_* constant definitions */</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>pipe2</span><span class=p>(</span><span class=kt>int</span> <span class=n>pipefd</span><span class=p>[</span><span class=mi>2</span><span class=p>],</span> <span class=kt>int</span> <span class=n>flags</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//正常0, 异常-1
</span></span></span><span class=line><span class=cl><span class=c1>//数组中0为可读的，1为可写的
</span></span></span></code></pre></td></tr></table></div></div><h4 id=422fifo非血缘管道命名管道>4.2.2.fifo非血缘管道(命名管道)<a hidden class=anchor aria-hidden=true href=#422fifo非血缘管道命名管道>#</a></h4><ul><li>可以同时多端读多端写</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/types.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/stat.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>mkfifo</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>pathname</span><span class=p>,</span> <span class=kt>mode_t</span> <span class=n>mode</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* Definition of AT_* constants */</span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;fcntl.h&gt;  </span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/stat.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>mkfifoat</span><span class=p>(</span><span class=kt>int</span> <span class=n>dirfd</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>pathname</span><span class=p>,</span> <span class=kt>mode_t</span> <span class=n>mode</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//然后用open打开即可
</span></span></span></code></pre></td></tr></table></div></div><h4 id=423mmap共享内存映射>4.2.3.mmap共享内存映射<a hidden class=anchor aria-hidden=true href=#423mmap共享内存映射>#</a></h4><ol><li>创建映射区过程中隐含了一次文件读取操作，所以需要读取权限</li><li>映射区权限需要小于或者等于文件权限，标志无所谓</li><li>文件关闭对已创建的映射区无影响，映射区创建后即可关闭文件</li><li>映射区大小不能为0，所以用于映射的文件必须有实际大小，mmap总线错误一般都是共享文件储存大小引起的</li><li>munmap传入的指针地址一定是mmap返回的地址</li><li>文件偏移量必须是4K的整数倍，因为一页就相当于4K</li><li>mmap出错概率很高，需要仔细检查返回值</li><li>利用mmap进行父子通信时，MAP_SHARED可以正常工作，MAP_PRICATE则不行，相当于映射区私有不共享。</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/mman.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span><span class=nf>mmap</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>addr</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>length</span><span class=p>,</span> <span class=kt>int</span> <span class=n>prot</span><span class=p>,</span>    <span class=kt>int</span> <span class=n>flags</span><span class=p>,</span> <span class=kt>int</span> <span class=n>fd</span><span class=p>,</span> <span class=kt>off_t</span> <span class=n>offset</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>munmap</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>addr</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>length</span><span class=p>);</span>  <span class=c1>//关闭映射区
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>若addr为NULL，则内核自动分配
</span></span></span><span class=line><span class=cl><span class=cm>prot为权限，读，写，执行
</span></span></span><span class=line><span class=cl><span class=cm>flags设置映射区修改是否反映到物理磁盘上
</span></span></span><span class=line><span class=cl><span class=cm>    MAP_SHARED  #会反映到物理磁盘上 
</span></span></span><span class=line><span class=cl><span class=cm>    MAP_PRIVATE #不会反映到无力磁盘上
</span></span></span><span class=line><span class=cl><span class=cm>offset文件的偏移量(4K的整数倍)
</span></span></span><span class=line><span class=cl><span class=cm>返回值:
</span></span></span><span class=line><span class=cl><span class=cm>成功: 返回创建映射区的首地址
</span></span></span><span class=line><span class=cl><span class=cm>失败: 返回MAP_FAILED宏
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>详情查看man文档
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=424mmap匿名映射区>4.2.4.mmap匿名映射区<a hidden class=anchor aria-hidden=true href=#424mmap匿名映射区>#</a></h4><ul><li>使用宏MAP_ANONYMOUS(或MAP_ANON)</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>//大小随意
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=nf>mmap</span><span class=p>(</span><span class=nb>NULL</span><span class=p>,</span><span class=mi>4</span><span class=p>,</span><span class=n>PROT_READ</span><span class=o>|</span><span class=n>PROT_WRITE</span><span class=p>,</span><span class=n>MAP_SHARED</span><span class=o>|</span><span class=n>MAP_ANONYMOUS</span><span class=p>,</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span><span class=mi>0</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p><img alt=012 loading=lazy src=../img/012.jpg></p><h4 id=425mmap非血缘进程通信>4.2.5.mmap非血缘进程通信<a hidden class=anchor aria-hidden=true href=#425mmap非血缘进程通信>#</a></h4><ul><li>mmap指向同一个文件，并且shared即可</li><li>可多端读多端写</li></ul><h4 id=426用文件进行进程间通信>4.2.6.用文件进行进程间通信<a hidden class=anchor aria-hidden=true href=#426用文件进行进程间通信>#</a></h4><ul><li>同理</li></ul><h3 id=5信号>5.信号<a hidden class=anchor aria-hidden=true href=#5信号>#</a></h3><h4 id=51信号基本概念>5.1.信号基本概念<a hidden class=anchor aria-hidden=true href=#51信号基本概念>#</a></h4><ul><li>简单 #只能带一个简单标志</li><li>不占内存 #用或不用信号都是一样内存占用</li><li>信号是由软件方式实现的(软中断)，所以其具有很强的延时性，但对于用户来说不易察觉</li><li><strong>每个进程收到的信号都是由内核负责发送的，内核处理</strong></li><li></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://Kyle-Derrick.github.io/zh/tags/linux/>Linux</a></li><li><a href=https://Kyle-Derrick.github.io/zh/tags/c/>C</a></li></ul><nav class=paginav><a class=prev href=https://Kyle-Derrick.github.io/zh/posts/tech/c/linux_c_02_%E5%9F%BA%E7%A1%80%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0/><span class=title>« 上一页</span><br><span>Linuc C 基础系统函数 (02)</span>
</a><a class=next href=https://Kyle-Derrick.github.io/zh/posts/tech/network/knowledge/udp%E6%89%93%E6%B4%9E%E5%8E%9F%E7%90%86%E5%8F%8A%E6%B5%81%E7%A8%8B/><span class=title>下一页 »</span><br><span>UDP打洞原理及流程</span></a></nav></footer><script src=https://giscus.app/client.js data-repo=Kyle-Derrick/Kyle-Derrick.github.io data-repo-id=R_kgDOOqQLVA data-category=Announcements data-category-id=DIC_kwDOOqQLVM4CtPKE data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=zh-CN crossorigin=anonymous async></script></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>