<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>CMake 基础 | Kyle's Notebook</title><meta name=keywords content="C,CMake"><meta name=description content="来源于多年前记录的笔记"><meta name=author content="kyle"><link rel=canonical href=https://Kyle-Derrick.github.io/zh/posts/tech/c/cmake%E5%9F%BA%E7%A1%80/><link crossorigin=anonymous href=/assets/css/stylesheet.7d51e19d4bcbbde3c3bab454b80362f047a8942bb44a2f0391c133400340f933.css integrity="sha256-fVHhnUvLvePDurRUuANi8EeolCu0Si8DkcEzQANA+TM=" rel="preload stylesheet" as=style><link rel=icon href=https://Kyle-Derrick.github.io/img/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://Kyle-Derrick.github.io/img/favicon-16x16.ico><link rel=icon type=image/png sizes=32x32 href=https://Kyle-Derrick.github.io/img/favicon-32x32.ico><link rel=apple-touch-icon href=https://Kyle-Derrick.github.io/img/apple-touch-icon.png><link rel=mask-icon href=https://Kyle-Derrick.github.io/img/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://Kyle-Derrick.github.io/zh/posts/tech/c/cmake%E5%9F%BA%E7%A1%80/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://Kyle-Derrick.github.io/zh/posts/tech/c/cmake%E5%9F%BA%E7%A1%80/"><meta property="og:site_name" content="Kyle's Notebook"><meta property="og:title" content="CMake 基础"><meta property="og:description" content="来源于多年前记录的笔记"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-07-26T16:19:38+08:00"><meta property="article:modified_time" content="2025-07-26T16:19:38+08:00"><meta property="article:tag" content="C"><meta property="article:tag" content="CMake"><meta name=twitter:card content="summary"><meta name=twitter:title content="CMake 基础"><meta name=twitter:description content="来源于多年前记录的笔记"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"文章","item":"https://Kyle-Derrick.github.io/zh/posts/"},{"@type":"ListItem","position":2,"name":"技术类","item":"https://Kyle-Derrick.github.io/zh/posts/tech/"},{"@type":"ListItem","position":3,"name":"C相关","item":"https://Kyle-Derrick.github.io/zh/posts/tech/c/"},{"@type":"ListItem","position":4,"name":"CMake 基础","item":"https://Kyle-Derrick.github.io/zh/posts/tech/c/cmake%E5%9F%BA%E7%A1%80/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"CMake 基础","name":"CMake 基础","description":"来源于多年前记录的笔记","keywords":["C","CMake"],"articleBody":"1. CMake概述 CMake 是一个项目构建工具，并且是跨平台的。关于项目构建我们所熟知的还有Makefile（通过 make 命令进行项目的构建），大多是IDE软件都集成了make，比如：VS 的 nmake、linux 下的 GNU make、Qt 的 qmake等，如果自己动手写 makefile，会发现，makefile 通常依赖于当前的编译平台，而且编写 makefile 的工作量比较大，解决依赖关系时也容易出错。\n而 CMake 恰好能解决上述问题， 其允许开发者指定整个工程的编译流程，在根据编译平台，自动生成本地化的Makefile和工程文件，最后用户只需make编译即可，所以可以把CMake看成一款自动生成 Makefile的工具，其编译流程如下图：\n蓝色虚线表示使用makefile构建项目的过程 红色实线表示使用cmake构建项目的过程 介绍完CMake的作用之后，再来总结一下它的优点：\n跨平台 能够管理大型项目 简化编译构建过程和编译过程 可扩展：可以为 cmake 编写特定功能的模块，扩充 cmake 功能 2. CMake的使用 CMake支持大写、小写、混合大小写的命令。如果在编写CMakeLists.txt文件时使用的工具有对应的命令提示，那么大小写随缘即可，不要太过在意。\n2.1 注释 2.1.1 注释行 CMake 使用 # 进行行注释，可以放在任何位置。\n1\n2\n# 这是一个 CMakeLists.txt 文件\ncmake_minimum_required(VERSION 3.0.0)\n2.1.2 注释块 CMake 使用 #[[ ]] 形式进行块注释。\n1\n2\n3\n4\n#[[ 这是一个 CMakeLists.txt 文件。\n这是一个 CMakeLists.txt 文件\n这是一个 CMakeLists.txt 文件]]\ncmake_minimum_required(VERSION 3.0.0)\n2.1 只有源文件 2.1.1 共处一室 准备工作，为了方便测试，在我本地电脑准备了这么几个测试文件\nadd.c\n1\n2\n3\n4\n5\n6\n7\n#include #include \"head.h\"\nint add(int a, int b)\n{\nreturn a+b;\n}\nsub.c\n1\n2\n3\n4\n5\n6\n7\n8\n#include #include \"head.h\"\n// 你好\nint subtract(int a, int b)\n{\nreturn a-b;\n}\nmult.c\n1\n2\n3\n4\n5\n6\n7\n#include #include \"head.h\"\nint multiply(int a, int b)\n{\nreturn a*b;\n}\ndiv.c\n1\n2\n3\n4\n5\n6\n7\n#include #include \"head.h\"\ndouble divide(int a, int b)\n{\nreturn (double)a/b;\n}\nhead.h\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n#ifndef _HEAD_H\n#define _HEAD_H\n// 加法\nint add(int a, int b);\n// 减法\nint subtract(int a, int b);\n// 乘法\nint multiply(int a, int b);\n// 除法\ndouble divide(int a, int b);\n#endif\nmain.c\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n#include #include \"head.h\"\nint main()\n{\nint a = 20;\nint b = 12;\nprintf(\"a = %d, b = %d\\n\", a, b);\nprintf(\"a + b = %d\\n\", add(a, b));\nprintf(\"a - b = %d\\n\", subtract(a, b));\nprintf(\"a * b = %d\\n\", multiply(a, b));\nprintf(\"a / b = %f\\n\", divide(a, b));\nreturn 0;\n}\n上述文件的目录结构如下：\n1\n2\n3\n4\n5\n6\n7\n8\n$ tree\n.\n├── add.c\n├── div.c\n├── head.h\n├── main.c\n├── mult.c\n└── sub.c\n添加 CMakeLists.txt 文件\n在上述源文件所在目录下添加一个新文件 CMakeLists.txt，文件内容如下：\n1\n2\n3\ncmake_minimum_required(VERSION 3.0)\nproject(CALC)\nadd_executable(app add.c div.c main.c mult.c sub.c)\n接下来依次介绍一下在 CMakeLists.txt 文件中添加的三个命令:\ncmake_minimum_required：指定使用的 cmake 的最低版本\n可选，非必须，如果不加可能会有警告 project：定义工程名称，并可指定工程的版本、工程描述、web主页地址、支持的语言（默认情况支持所有语言），如果不需要这些都是可以忽略的，只需要指定出工程名字即可。\n1\n2\n3\n4\n5\n6\n7\n# PROJECT 指令的语法是：\nproject(\u003cPROJECT-NAME\u003e [...])\nproject(\u003cPROJECT-NAME\u003e\n[VERSION [.[.[.]]]]\n[DESCRIPTION \u003cproject-description-string\u003e]\n[HOMEPAGE_URL ","wordCount":"10491","inLanguage":"zh","datePublished":"2025-07-26T16:19:38+08:00","dateModified":"2025-07-26T16:19:38+08:00","author":[{"@type":"Person","name":"kyle"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://Kyle-Derrick.github.io/zh/posts/tech/c/cmake%E5%9F%BA%E7%A1%80/"},"publisher":{"@type":"Organization","name":"Kyle's Notebook","logo":{"@type":"ImageObject","url":"https://Kyle-Derrick.github.io/img/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://Kyle-Derrick.github.io/zh/ accesskey=h title="Kyle's Notebook (Alt + H)">Kyle's Notebook</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://Kyle-Derrick.github.io/zh/search title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://Kyle-Derrick.github.io/zh/ title=主页><span>主页</span></a></li><li><a href=https://Kyle-Derrick.github.io/zh/posts title=文章><span>文章</span></a></li><li><a href=https://Kyle-Derrick.github.io/zh/archives title=时间轴><span>时间轴</span></a></li><li><a href=https://Kyle-Derrick.github.io/zh/tags title=标签><span>标签</span></a></li><li><a href=https://Kyle-Derrick.github.io/zh/about title=关于><span>关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://Kyle-Derrick.github.io/zh/>主页</a>&nbsp;»&nbsp;<a href=https://Kyle-Derrick.github.io/zh/posts/>文章</a>&nbsp;»&nbsp;<a href=https://Kyle-Derrick.github.io/zh/posts/tech/>技术类</a>&nbsp;»&nbsp;<a href=https://Kyle-Derrick.github.io/zh/posts/tech/c/>C相关</a>&nbsp;»&nbsp;<span class=breadcrumbs-current>CMake 基础</span></div><aside class=post-toc><span class=title>全部文章</span>
<dev class=post-toc-tree><details open><summary class=summary-active accesskey=c title="(Alt + C)"><a href=/zh/posts/tech/ class=node-active>技术类</a></summary><dev class=sub-tree><details open><summary class=summary-active accesskey=c title="(Alt + C)"><a href=/zh/posts/tech/c/ class=node-active>C相关</a></summary><dev class=sub-tree><a href=/zh/posts/tech/c/cmake%E5%9F%BA%E7%A1%80/ class="tree-node node-active">CMake 基础</a>
<a href=/zh/posts/tech/c/linux_c_01_%E5%9F%BA%E7%A1%80/ class=tree-node>Linuc C 基础 (01)</a>
<a href=/zh/posts/tech/c/linux_c_02_%E5%9F%BA%E7%A1%80%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0/ class=tree-node>Linuc C 基础系统函数 (02)</a>
<a href=/zh/posts/tech/c/linux_c_03_%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/ class=tree-node>Linuc C 进程线程 (03)</a></dev></details><details><summary accesskey=c title="(Alt + C)"><a href=/zh/posts/tech/open_source_favorites/>开源收藏夹</a></summary><dev class=sub-tree><a href=/zh/posts/tech/open_source_favorites/%E4%BA%92%E8%81%94barrier/ class=tree-node>互联Barrier安装记录</a>
<a href=/zh/posts/tech/open_source_favorites/open_source_lib/ class=tree-node>开源库搜寻记录</a></dev></details><details><summary accesskey=c title="(Alt + C)"><a href=/zh/posts/tech/system_level/>系统层面相关</a></summary><dev class=sub-tree><a href=/zh/posts/tech/system_level/%E5%86%85%E5%AD%98%E7%BC%93%E5%86%B2%E5%8C%BA%E4%BC%AA%E8%A3%85%E6%96%87%E4%BB%B6%E6%B5%81/ class=tree-node>如何将内存缓冲区伪装成文件流</a></dev></details><details><summary accesskey=c title="(Alt + C)"><a href=/zh/posts/tech/linux/>Linux相关</a></summary><dev class=sub-tree><a href=/zh/posts/tech/linux/esxi7%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%85%8B%E9%9A%86%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%8E%B0/ class=tree-node>ESXi7虚拟机克隆脚本实现</a>
<a href=/zh/posts/tech/linux/ubuntu%E6%B8%85%E5%8D%8E%E6%BA%90/ class=tree-node>Ubuntu清华源配置</a>
<a href=/zh/posts/tech/linux/%E5%8F%8C%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4%E9%97%AE%E9%A2%98/ class=tree-node>双系统时间问题</a>
<a href=/zh/posts/tech/linux/linux%E4%BD%9C%E4%B8%BA%E7%BD%91%E5%85%B3%E6%8F%90%E4%BE%9B%E8%B7%AF%E7%94%B1/ class=tree-node>linux作为网关提供路由</a>
<a href=/zh/posts/tech/linux/ipsec_ikev2%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2/ class=tree-node>IPsec/IKEv2服务部署</a>
<a href=/zh/posts/tech/linux/wireguard%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2/ class=tree-node>WireGuard服务部署</a>
<a href=/zh/posts/tech/linux/smb%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2/ class=tree-node>SMB服务部署</a>
<a href=/zh/posts/tech/linux/centos7%E6%9C%80%E5%B0%8F%E5%AE%89%E8%A3%85%E5%90%8E%E9%85%8D%E7%BD%AE/ class=tree-node>CentOS7最小安装后配置</a>
<a href=/zh/posts/tech/linux/centos7%E4%BD%BF%E7%94%A8%E9%AB%98%E7%89%88%E6%9C%ACgcc/ class=tree-node>CentOS7 使用高版本gcc</a>
<a href=/zh/posts/tech/linux/centos7_nodejs%E5%AE%89%E8%A3%85/ class=tree-node>CentOS7 上安装 NodeJs</a></dev></details><details><summary accesskey=c title="(Alt + C)"><a href=/zh/posts/tech/network/>网络相关</a></summary><dev class=sub-tree><details><summary accesskey=c title="(Alt + C)"><a href=/zh/posts/tech/network/vpn/>VPN相关</a></summary><dev class=sub-tree><details><summary accesskey=c title="(Alt + C)"><a href=/zh/posts/tech/network/vpn/ipsec/>IPsec VPN相关</a></summary><dev class=sub-tree><a href=/zh/posts/tech/network/vpn/ipsec/strongswan%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/ class=tree-node>StrongSwan安装部署（CentOS7 为例）</a>
<a href=/zh/posts/tech/network/vpn/ipsec/ipsec%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/ class=tree-node>IPsec技术原理</a></dev></details></dev></details><details><summary accesskey=c title="(Alt + C)"><a href=/zh/posts/tech/network/knowledge/>网络相关知识点</a></summary><dev class=sub-tree><a href=/zh/posts/tech/network/knowledge/udp%E6%89%93%E6%B4%9E%E5%8E%9F%E7%90%86%E5%8F%8A%E6%B5%81%E7%A8%8B/ class=tree-node>UDP打洞原理及流程</a></dev></details></dev></details><details><summary accesskey=c title="(Alt + C)"><a href=/zh/posts/tech/plan/>学习或研究计划</a></summary><dev class=sub-tree><a href=/zh/posts/tech/plan/%E6%BA%90%E7%A0%81%E7%A0%94%E7%A9%B6%E8%AE%A1%E5%88%92/ class=tree-node>源码研究计划（源于AI推荐）</a></dev></details><details><summary accesskey=c title="(Alt + C)"><a href=/zh/posts/tech/rust/>Rust相关</a></summary><dev class=sub-tree><a href=/zh/posts/tech/rust/%E8%AE%B0%E5%BD%95%E7%82%B9/ class=tree-node>Rust杂项记录点</a>
<a href=/zh/posts/tech/rust/%E5%9B%BD%E5%86%85%E6%BA%90%E5%AE%89%E8%A3%85/ class=tree-node>Rust国内源安装</a>
<a href=/zh/posts/tech/rust/%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E5%8F%8A%E7%A6%BB%E7%BA%BF%E4%BE%9D%E8%B5%96/ class=tree-node>Rust离线环境安装及使用vendor离线编译项目</a></dev></details><details><summary accesskey=c title="(Alt + C)"><a href=/zh/posts/tech/open_source_component/>开源组件</a></summary><dev class=sub-tree><details><summary accesskey=c title="(Alt + C)"><a href=/zh/posts/tech/open_source_component/java_web_base/>Java Web 基本框架相关</a></summary><dev class=sub-tree></dev></details><details><summary accesskey=c title="(Alt + C)"><a href=/zh/posts/tech/open_source_component/redis/>Redis相关</a></summary><dev class=sub-tree><a href=/zh/posts/tech/open_source_component/redis/redis%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/ class=tree-node>Redis基本命令</a>
<a href=/zh/posts/tech/open_source_component/redis/redis_concurrency_case/ class=tree-node>Redis并发相关使用案例</a></dev></details></dev></details><details><summary accesskey=c title="(Alt + C)"><a href=/zh/posts/tech/java/>Java相关</a></summary><dev class=sub-tree><a href=/zh/posts/tech/java/maven_gradle_mirror/ class=tree-node>Maven、Gradle国内源配置</a></dev></details><details><summary accesskey=c title="(Alt + C)"><a href=/zh/posts/tech/other_general/>其他通用</a></summary><dev class=sub-tree><details><summary accesskey=c title="(Alt + C)"><a href=/zh/posts/tech/other_general/hugo/>hugo</a></summary><dev class=sub-tree><a href=/zh/posts/tech/other_general/hugo/hugo_include_image/ class=tree-node>hugo从同级目录下插入图片（相对路径）</a>
<a href=/zh/posts/tech/other_general/hugo/hugo_exp_note/ class=tree-node>hugo使用经验</a>
<a href=/zh/posts/tech/other_general/hugo/hugo_giscus_comment/ class=tree-node>hugo使用Giscus支持评论</a>
<a href=/zh/posts/tech/other_general/hugo/hugo_and_github_pages/ class=tree-node>Hugo使用PaperMod主题搭建博客，并配置自动发布Github Pages</a></dev></details></dev></details><details><summary accesskey=c title="(Alt + C)"><a href=/zh/posts/tech/vscode/>vs-code相关</a></summary><dev class=sub-tree><a href=/zh/posts/tech/vscode/vscode-project-config/ class=tree-node>vscode项目级配置</a></dev></details></dev></details><details><summary accesskey=c title="(Alt + C)"><a href=/zh/posts/life/>生活类</a></summary><dev class=sub-tree></dev></details><details><summary accesskey=c title="(Alt + C)"><a href=/zh/posts/read/>阅读类</a></summary><dev class=sub-tree></dev></details></dev></aside><hr><h1 class="post-title entry-hint-parent">CMake 基础</h1><div class=post-description>来源于多年前记录的笔记</div><div class=post-meta><span title='2025-07-26 16:19:38 +0800 +0800'>2025-07-26</span>&nbsp;·&nbsp;21 分钟&nbsp;·&nbsp;kyle</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#1-cmake%e6%a6%82%e8%bf%b0 aria-label="1. CMake概述">1. CMake概述</a></li><li><a href=#2-cmake%e7%9a%84%e4%bd%bf%e7%94%a8 aria-label="2. CMake的使用">2. CMake的使用</a></li><li><a href=#21-%e6%b3%a8%e9%87%8a aria-label="2.1 注释">2.1 注释</a><ul><li><a href=#211-%e6%b3%a8%e9%87%8a%e8%a1%8c aria-label="2.1.1 注释行">2.1.1 注释行</a></li><li><a href=#212-%e6%b3%a8%e9%87%8a%e5%9d%97 aria-label="2.1.2 注释块">2.1.2 注释块</a></li></ul></li><li><a href=#21-%e5%8f%aa%e6%9c%89%e6%ba%90%e6%96%87%e4%bb%b6 aria-label="2.1 只有源文件">2.1 只有源文件</a><ul><li><a href=#211-%e5%85%b1%e5%a4%84%e4%b8%80%e5%ae%a4 aria-label="2.1.1 共处一室">2.1.1 共处一室</a></li><li><a href=#212-vip-%e5%8c%85%e6%88%bf aria-label="2.1.2 VIP 包房">2.1.2 VIP 包房</a></li></ul></li><li><a href=#22-%e7%a7%81%e4%ba%ba%e8%ae%a2%e5%88%b6 aria-label="2.2 私人订制">2.2 私人订制</a><ul><li><a href=#221-%e5%ae%9a%e4%b9%89%e5%8f%98%e9%87%8f aria-label="2.2.1 定义变量">2.2.1 定义变量</a></li><li><a href=#222-%e6%8c%87%e5%ae%9a%e4%bd%bf%e7%94%a8%e7%9a%84c%e6%a0%87%e5%87%86 aria-label="2.2.2 指定使用的C++标准">2.2.2 指定使用的C++标准</a></li><li><a href=#223-%e6%8c%87%e5%ae%9a%e8%be%93%e5%87%ba%e7%9a%84%e8%b7%af%e5%be%84 aria-label="2.2.3 指定输出的路径">2.2.3 指定输出的路径</a></li></ul></li><li><a href=#23-%e6%90%9c%e7%b4%a2%e6%96%87%e4%bb%b6 aria-label="2.3 搜索文件">2.3 搜索文件</a><ul><li><a href=#231-%e6%96%b9%e5%bc%8f1 aria-label="2.3.1 方式1">2.3.1 方式1</a></li><li><a href=#232-%e6%96%b9%e5%bc%8f2 aria-label="2.3.2 方式2">2.3.2 方式2</a></li></ul></li><li><a href=#24-%e5%8c%85%e5%90%ab%e5%a4%b4%e6%96%87%e4%bb%b6 aria-label="2.4 包含头文件">2.4 包含头文件</a></li><li><a href=#25-%e5%88%b6%e4%bd%9c%e5%8a%a8%e6%80%81%e5%ba%93%e6%88%96%e9%9d%99%e6%80%81%e5%ba%93 aria-label="2.5 制作动态库或静态库">2.5 制作动态库或静态库</a><ul><li><a href=#251-%e5%88%b6%e4%bd%9c%e9%9d%99%e6%80%81%e5%ba%93 aria-label="2.5.1 制作静态库">2.5.1 制作静态库</a></li><li><a href=#252-%e5%88%b6%e4%bd%9c%e5%8a%a8%e6%80%81%e5%ba%93 aria-label="2.5.2 制作动态库">2.5.2 制作动态库</a></li><li><a href=#253-%e6%8c%87%e5%ae%9a%e8%be%93%e5%87%ba%e7%9a%84%e8%b7%af%e5%be%84 aria-label="2.5.3 指定输出的路径">2.5.3 指定输出的路径</a><ul><li><a href=#%e6%96%b9%e5%bc%8f1---%e9%80%82%e7%94%a8%e4%ba%8e%e5%8a%a8%e6%80%81%e5%ba%93 aria-label="方式1 - 适用于动态库">方式1 - 适用于动态库</a></li><li><a href=#%e6%96%b9%e5%bc%8f2---%e9%83%bd%e9%80%82%e7%94%a8 aria-label="方式2 - 都适用">方式2 - 都适用</a></li></ul></li></ul></li><li><a href=#26-%e5%8c%85%e5%90%ab%e5%ba%93%e6%96%87%e4%bb%b6 aria-label="2.6 包含库文件">2.6 包含库文件</a><ul><li><a href=#261-%e9%93%be%e6%8e%a5%e9%9d%99%e6%80%81%e5%ba%93 aria-label="2.6.1 链接静态库">2.6.1 链接静态库</a></li><li><a href=#262-%e9%93%be%e6%8e%a5%e5%8a%a8%e6%80%81%e5%ba%93 aria-label="2.6.2 链接动态库">2.6.2 链接动态库</a><ul><li><a href=#%e9%93%be%e6%8e%a5%e7%b3%bb%e7%bb%9f%e5%8a%a8%e6%80%81%e5%ba%93 aria-label=链接系统动态库>链接系统动态库</a></li><li><a href=#%e9%93%be%e6%8e%a5%e7%ac%ac%e4%b8%89%e6%96%b9%e5%8a%a8%e6%80%81%e5%ba%93 aria-label=链接第三方动态库>链接第三方动态库</a></li></ul></li></ul></li><li><a href=#27-%e6%97%a5%e5%bf%97 aria-label="2.7 日志">2.7 日志</a></li><li><a href=#28-%e5%8f%98%e9%87%8f%e6%93%8d%e4%bd%9c aria-label="2.8 变量操作">2.8 变量操作</a><ul><li><a href=#281-%e8%bf%bd%e5%8a%a0 aria-label="2.8.1 追加">2.8.1 追加</a><ul><li><a href=#%e4%bd%bf%e7%94%a8set%e6%8b%bc%e6%8e%a5 aria-label=使用set拼接>使用set拼接</a></li><li><a href=#%e4%bd%bf%e7%94%a8list%e6%8b%bc%e6%8e%a5 aria-label=使用list拼接>使用list拼接</a></li></ul></li><li><a href=#282-%e5%ad%97%e7%ac%a6%e4%b8%b2%e7%a7%bb%e9%99%a4 aria-label="2.8.2 字符串移除">2.8.2 字符串移除</a></li></ul></li><li><a href=#29-%e5%ae%8f%e5%ae%9a%e4%b9%89 aria-label="2.9 宏定义">2.9 宏定义</a></li><li><a href=#3-%e9%a2%84%e5%ae%9a%e4%b9%89%e5%ae%8f aria-label="3. 预定义宏">3. 预定义宏</a></li></ul></div></details></div><script>document.addEventListener("DOMContentLoaded",function(){const n=document.querySelectorAll(".toc a"),i=Array.from(n).map(e=>{const t=e.getAttribute("href").substring(1);return document.getElementById(decodeURI(t))});let e=[];function s(){if(window.innerWidth<1280){e.length>0&&(e.forEach(e=>e.classList.remove("toc-active")),e=[]);return}const t=window.scrollY;i.forEach((s,o)=>{if(!s)return;const r=s.offsetTop,l=s.offsetHeight,a=i[o+1],c=a?a.offsetTop:1/0;t>=r&&t<c&&(e.forEach(e=>e.classList.remove("toc-active")),e=[],n[o].classList.add("toc-active"),e.push(n[o]))})}var o=document.querySelector(".toc"),t=document.querySelector(".toc details");function a(){window.innerWidth>=1280&&o.classList.contains("toc-closed")&&t.removeAttribute("open"),s()}window.addEventListener("resize",a),t&&t.addEventListener("toggle",function(){if(window.innerWidth<1280)return;t.open?o.classList.remove("toc-closed"):o.classList.add("toc-closed")}),window.addEventListener("scroll",s),s()})</script><div class=post-content><h2 id=1-cmake概述><a href=/zh/posts/tech/c/cmake%E5%9F%BA%E7%A1%80/#1-CMake%e6%a6%82%e8%bf%b0 title="1. CMake概述"></a>1. CMake概述<a hidden class=anchor aria-hidden=true href=#1-cmake概述>#</a></h2><p>CMake 是一个项目构建工具，并且是跨平台的。关于项目构建我们所熟知的还有Makefile（通过 make 命令进行项目的构建），大多是IDE软件都集成了make，比如：VS 的 nmake、linux 下的 GNU make、Qt 的 qmake等，如果自己动手写 makefile，会发现，makefile 通常依赖于当前的编译平台，而且编写 makefile 的工作量比较大，解决依赖关系时也容易出错。</p><p>而 CMake 恰好能解决上述问题， 其允许开发者指定整个工程的编译流程，在根据编译平台，<code>自动生成本地化的Makefile和工程文件</code>，最后用户只需<code>make</code>编译即可，所以可以把CMake看成一款自动生成 Makefile的工具，其编译流程如下图：</p><p><img alt=image-20230309130644912 loading=lazy src=../img/CMake基础/image.png></p><ul><li>蓝色虚线表示使用<code>makefile</code>构建项目的过程</li><li>红色实线表示使用<code>cmake</code>构建项目的过程</li></ul><p>介绍完CMake的作用之后，再来总结一下它的优点：</p><ul><li>跨平台</li><li>能够管理大型项目</li><li>简化编译构建过程和编译过程</li><li>可扩展：可以为 cmake 编写特定功能的模块，扩充 cmake 功能</li></ul><h2 id=2-cmake的使用><a href=/zh/posts/tech/c/cmake%E5%9F%BA%E7%A1%80/#2-CMake%e7%9a%84%e4%bd%bf%e7%94%a8 title="2. CMake的使用"></a>2. CMake的使用<a hidden class=anchor aria-hidden=true href=#2-cmake的使用>#</a></h2><p><code>CMake</code>支持大写、小写、混合大小写的命令。如果在编写<code>CMakeLists.txt</code>文件时使用的工具有对应的命令提示，那么大小写随缘即可，不要太过在意。</p><h2 id=21-注释><a href=/zh/posts/tech/c/cmake%E5%9F%BA%E7%A1%80/#2-1-%e6%b3%a8%e9%87%8a title="2.1 注释"></a>2.1 注释<a hidden class=anchor aria-hidden=true href=#21-注释>#</a></h2><h3 id=211-注释行><a href=/zh/posts/tech/c/cmake%E5%9F%BA%E7%A1%80/#2-1-1-%e6%b3%a8%e9%87%8a%e8%a1%8c title="2.1.1 注释行"></a>2.1.1 注释行<a hidden class=anchor aria-hidden=true href=#211-注释行>#</a></h3><p><code>CMake</code> 使用 <code>#</code> 进行<code>行注释</code>，可以放在任何位置。</p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre></td><td class=code><pre><span class=line><span class=comment># 这是一个 CMakeLists.txt 文件</span></span><br><span class=line><span class=keyword>cmake_minimum_required</span>(VERSION <span class=number>3.0</span>.<span class=number>0</span>)</span><br></pre></td></tr></tbody></table><h3 id=212-注释块><a href=/zh/posts/tech/c/cmake%E5%9F%BA%E7%A1%80/#2-1-2-%e6%b3%a8%e9%87%8a%e5%9d%97 title="2.1.2 注释块"></a>2.1.2 注释块<a hidden class=anchor aria-hidden=true href=#212-注释块>#</a></h3><p><code>CMake</code> 使用 <code>#[[ ]]</code> 形式进行<code>块注释</code>。</p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre></td><td class=code><pre><span class=line><span class=comment>#[[ 这是一个 CMakeLists.txt 文件。</span></span><br><span class=line><span class=comment>这是一个 CMakeLists.txt 文件</span></span><br><span class=line><span class=comment>这是一个 CMakeLists.txt 文件]]</span></span><br><span class=line><span class=keyword>cmake_minimum_required</span>(VERSION <span class=number>3.0</span>.<span class=number>0</span>)</span><br></pre></td></tr></tbody></table><h2 id=21-只有源文件><a href=/zh/posts/tech/c/cmake%E5%9F%BA%E7%A1%80/#2-1-%e5%8f%aa%e6%9c%89%e6%ba%90%e6%96%87%e4%bb%b6 title="2.1 只有源文件"></a>2.1 只有源文件<a hidden class=anchor aria-hidden=true href=#21-只有源文件>#</a></h2><h3 id=211-共处一室><a href=/zh/posts/tech/c/cmake%E5%9F%BA%E7%A1%80/#2-1-1-%e5%85%b1%e5%a4%84%e4%b8%80%e5%ae%a4 title="2.1.1 共处一室"></a>2.1.1 共处一室<a hidden class=anchor aria-hidden=true href=#211-共处一室>#</a></h3><ol><li><p>准备工作，为了方便测试，在我本地电脑准备了这么几个测试文件</p><ul><li><p><strong>add.c</strong></p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre></td><td class=code><pre><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;stdio.h&gt;</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>"head.h"</span></span></span><br><span class=line></span><br><span class=line><span class=function><span class=type>int</span> <span class=title>add</span><span class=params>(<span class=type>int</span> a, <span class=type>int</span> b)</span></span></span><br><span class=line><span class=function></span>{</span><br><span class=line>    <span class=keyword>return</span> a+b;</span><br><span class=line>}</span><br></pre></td></tr></tbody></table></li><li><p><strong>sub.c</strong></p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre></td><td class=code><pre><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;stdio.h&gt;</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>"head.h"</span></span></span><br><span class=line></span><br><span class=line><span class=comment>// 你好</span></span><br><span class=line><span class=function><span class=type>int</span> <span class=title>subtract</span><span class=params>(<span class=type>int</span> a, <span class=type>int</span> b)</span></span></span><br><span class=line><span class=function></span>{</span><br><span class=line>    <span class=keyword>return</span> a-b;</span><br><span class=line>}</span><br></pre></td></tr></tbody></table></li><li><p><strong>mult.c</strong></p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre></td><td class=code><pre><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;stdio.h&gt;</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>"head.h"</span></span></span><br><span class=line></span><br><span class=line><span class=function><span class=type>int</span> <span class=title>multiply</span><span class=params>(<span class=type>int</span> a, <span class=type>int</span> b)</span></span></span><br><span class=line><span class=function></span>{</span><br><span class=line>    <span class=keyword>return</span> a*b;</span><br><span class=line>}</span><br></pre></td></tr></tbody></table></li><li><p><strong>div.c</strong></p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre></td><td class=code><pre><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;stdio.h&gt;</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>"head.h"</span></span></span><br><span class=line></span><br><span class=line><span class=function><span class=type>double</span> <span class=title>divide</span><span class=params>(<span class=type>int</span> a, <span class=type>int</span> b)</span></span></span><br><span class=line><span class=function></span>{</span><br><span class=line>    <span class=keyword>return</span> (<span class=type>double</span>)a/b;</span><br><span class=line>}</span><br></pre></td></tr></tbody></table></li><li><p><strong>head.h</strong></p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre></td><td class=code><pre><span class=line><span class=meta>#<span class=keyword>ifndef</span> _HEAD_H</span></span><br><span class=line><span class=meta>#<span class=keyword>define</span> _HEAD_H</span></span><br><span class=line><span class=comment>// 加法</span></span><br><span class=line><span class=function><span class=type>int</span> <span class=title>add</span><span class=params>(<span class=type>int</span> a, <span class=type>int</span> b)</span></span>;</span><br><span class=line><span class=comment>// 减法</span></span><br><span class=line><span class=function><span class=type>int</span> <span class=title>subtract</span><span class=params>(<span class=type>int</span> a, <span class=type>int</span> b)</span></span>;</span><br><span class=line><span class=comment>// 乘法</span></span><br><span class=line><span class=function><span class=type>int</span> <span class=title>multiply</span><span class=params>(<span class=type>int</span> a, <span class=type>int</span> b)</span></span>;</span><br><span class=line><span class=comment>// 除法</span></span><br><span class=line><span class=function><span class=type>double</span> <span class=title>divide</span><span class=params>(<span class=type>int</span> a, <span class=type>int</span> b)</span></span>;</span><br><span class=line><span class=meta>#<span class=keyword>endif</span></span></span><br></pre></td></tr></tbody></table></li><li><p><strong>main.c</strong></p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre></td><td class=code><pre><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;stdio.h&gt;</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>"head.h"</span></span></span><br><span class=line></span><br><span class=line><span class=function><span class=type>int</span> <span class=title>main</span><span class=params>()</span></span></span><br><span class=line><span class=function></span>{</span><br><span class=line>    <span class=type>int</span> a = <span class=number>20</span>;</span><br><span class=line>    <span class=type>int</span> b = <span class=number>12</span>;</span><br><span class=line>    <span class=built_in>printf</span>(<span class=string>"a = %d, b = %d\n"</span>, a, b);</span><br><span class=line>    <span class=built_in>printf</span>(<span class=string>"a + b = %d\n"</span>, <span class=built_in>add</span>(a, b));</span><br><span class=line>    <span class=built_in>printf</span>(<span class=string>"a - b = %d\n"</span>, <span class=built_in>subtract</span>(a, b));</span><br><span class=line>    <span class=built_in>printf</span>(<span class=string>"a * b = %d\n"</span>, <span class=built_in>multiply</span>(a, b));</span><br><span class=line>    <span class=built_in>printf</span>(<span class=string>"a / b = %f\n"</span>, <span class=built_in>divide</span>(a, b));</span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>}</span><br></pre></td></tr></tbody></table></li></ul></li><li><p>上述文件的目录结构如下：</p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre></td><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>tree</span></span><br><span class=line>.</span><br><span class=line>├── add.c</span><br><span class=line>├── div.c</span><br><span class=line>├── head.h</span><br><span class=line>├── main.c</span><br><span class=line>├── mult.c</span><br><span class=line>└── sub.c</span><br></pre></td></tr></tbody></table></li><li><p><strong>添加 <code>CMakeLists.txt</code> 文件</strong></p><p>在上述源文件所在目录下添加一个新文件 CMakeLists.txt，文件内容如下：</p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>cmake_minimum_required</span>(VERSION <span class=number>3.0</span>)</span><br><span class=line><span class=keyword>project</span>(CALC)</span><br><span class=line><span class=keyword>add_executable</span>(app add.c div.c main.c mult.c sub.c)</span><br></pre></td></tr></tbody></table><p>接下来依次介绍一下在 CMakeLists.txt 文件中添加的三个命令:</p><ul><li><p><code>cmake_minimum_required</code>：指定使用的 cmake 的最低版本</p><ul><li><strong>可选，非必须，如果不加可能会有警告</strong></li></ul></li><li><p><code>project</code>：定义工程名称，并可指定工程的版本、工程描述、web主页地址、支持的语言（默认情况支持所有语言），如果不需要这些都是可以忽略的，只需要指定出工程名字即可。</p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre></td><td class=code><pre><span class=line><span class=comment># PROJECT 指令的语法是：</span></span><br><span class=line><span class=keyword>project</span>(&lt;<span class=keyword>PROJECT</span>-NAME&gt; [&lt;language-name&gt;...])</span><br><span class=line><span class=keyword>project</span>(&lt;<span class=keyword>PROJECT</span>-NAME&gt;</span><br><span class=line>       [VERSION &lt;major&gt;[.&lt;minor&gt;[.&lt;patch&gt;[.&lt;tweak&gt;]]]]</span><br><span class=line>       [DESCRIPTION &lt;<span class=keyword>project</span>-description-<span class=keyword>string</span>&gt;]</span><br><span class=line>       [HOMEPAGE_URL &lt;url-<span class=keyword>string</span>&gt;]</span><br><span class=line>       [LANGUAGES &lt;language-name&gt;...])</span><br></pre></td></tr></tbody></table></li><li><p><code>add_executable</code>：定义工程会生成一个可执行程序</p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>add_executable</span>(可执行程序名 源文件名称)</span><br></pre></td></tr></tbody></table><ul><li><p>这里的可执行程序名和<code>project</code>中的项目名没有任何关系</p></li><li><p>源文件名可以是一个也可以是多个，如有多个可用空格或<code>;</code>间隔</p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre></td><td class=code><pre><span class=line><span class=comment># 样式1</span></span><br><span class=line><span class=keyword>add_executable</span>(app add.c div.c main.c mult.c sub.c)</span><br><span class=line><span class=comment># 样式2</span></span><br><span class=line><span class=keyword>add_executable</span>(app add.c;div.c;main.c;mult.c;sub.c)</span><br></pre></td></tr></tbody></table></li></ul></li></ul></li><li><p>执行<code>CMake</code> 命令</p><p>万事俱备只欠东风，将 CMakeLists.txt 文件编辑好之后，就可以执行 <code>cmake</code>命令了。</p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre></td><td class=code><pre><span class=line><span class="meta prompt_"># </span><span class=language-bash>cmake 命令原型</span></span><br><span class=line><span class="meta prompt_">$ </span><span class=language-bash>cmake CMakeLists.txt文件所在路径</span></span><br></pre></td></tr></tbody></table><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre></td><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>tree</span></span><br><span class=line>.</span><br><span class=line>├── add.c</span><br><span class=line>├── CMakeLists.txt</span><br><span class=line>├── div.c</span><br><span class=line>├── head.h</span><br><span class=line>├── main.c</span><br><span class=line>├── mult.c</span><br><span class=line>└── sub.c</span><br><span class=line></span><br><span class=line>0 directories, 7 files</span><br><span class=line>robin@OS:~/Linux/3Day/calc$ cmake .</span><br></pre></td></tr></tbody></table><p>当执行<code>cmake</code>命令之后，CMakeLists.txt 中的命令就会被执行，所以一定要注意给<code>cmake</code> 命令指定路径的时候一定不能出错。</p><p>执行命令之后，看一下源文件所在目录中是否多了一些文件：</p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre></td><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>tree -L 1</span></span><br><span class=line>.</span><br><span class=line>├── add.c</span><br><span class=line>├── CMakeCache.txt         # new add file</span><br><span class=line>├── CMakeFiles             # new add dir</span><br><span class=line>├── cmake_install.cmake    # new add file</span><br><span class=line>├── CMakeLists.txt</span><br><span class=line>├── div.c</span><br><span class=line>├── head.h</span><br><span class=line>├── main.c</span><br><span class=line>├── Makefile               # new add file</span><br><span class=line>├── mult.c</span><br><span class=line>└── sub.c</span><br></pre></td></tr></tbody></table><p>我们可以看到在对应的目录下生成了一个<code>makefile</code>文件，此时再执行<code>make</code>命令，就可以对项目进行构建得到所需的可执行程序了。</p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br></pre></td><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>make</span></span><br><span class=line>Scanning dependencies of target app</span><br><span class=line>[ 16%] Building C object CMakeFiles/app.dir/add.c.o</span><br><span class=line>[ 33%] Building C object CMakeFiles/app.dir/div.c.o</span><br><span class=line>[ 50%] Building C object CMakeFiles/app.dir/main.c.o</span><br><span class=line>[ 66%] Building C object CMakeFiles/app.dir/mult.c.o</span><br><span class=line>[ 83%] Building C object CMakeFiles/app.dir/sub.c.o</span><br><span class=line><span class="meta prompt_">[100%</span><span class=language-bash>] Linking C executable app</span></span><br><span class=line><span class="meta prompt_">[100%</span><span class=language-bash>] Built target app</span></span><br><span class=line><span class="meta prompt_"></span></span><br><span class=line><span class="meta prompt_"># </span><span class=language-bash>查看可执行程序是否已经生成</span></span><br><span class=line><span class="meta prompt_">$ </span><span class=language-bash>tree -L 1</span></span><br><span class=line>.</span><br><span class=line>├── add.c</span><br><span class=line>├── app					# 生成的可执行程序</span><br><span class=line>├── CMakeCache.txt</span><br><span class=line>├── CMakeFiles</span><br><span class=line>├── cmake_install.cmake</span><br><span class=line>├── CMakeLists.txt</span><br><span class=line>├── div.c</span><br><span class=line>├── head.h</span><br><span class=line>├── main.c</span><br><span class=line>├── Makefile</span><br><span class=line>├── mult.c</span><br><span class=line>└── sub.c</span><br></pre></td></tr></tbody></table><p>最终可执行程序<code>app</code>就被编译出来了（这个名字是在<code>CMakeLists.txt</code>中指定的）。</p></li></ol><h3 id=212-vip-包房><a href=/zh/posts/tech/c/cmake%E5%9F%BA%E7%A1%80/#2-1-2-VIP-%e5%8c%85%e6%88%bf title="2.1.2 VIP 包房"></a>2.1.2 VIP 包房<a hidden class=anchor aria-hidden=true href=#212-vip-包房>#</a></h3><p>通过上面的例子可以看出，如果在<code>CMakeLists.txt</code>文件所在目录执行了<code>cmake</code>命令之后就会生成一些目录和文件（<code>包括 makefile 文件</code>），如果再基于<code>makefile文件</code>执行<code>make</code>命令，程序在编译过程中还会生成一些中间文件和一个可执行文件，这样会导致整个项目目录看起来很混乱，不太容易管理和维护，此时我们就可以把生成的这些与项目源码无关的文件统一放到一个对应的目录里边，比如将这个目录命名为<code>build</code>:</p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br></pre></td><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash><span class=built_in>mkdir</span> build</span></span><br><span class=line><span class="meta prompt_">$ </span><span class=language-bash><span class=built_in>cd</span> build</span></span><br><span class=line><span class="meta prompt_">$ </span><span class=language-bash>cmake ..</span></span><br><span class=line>-- The C compiler identification is GNU 5.4.0</span><br><span class=line>-- The CXX compiler identification is GNU 5.4.0</span><br><span class=line>-- Check for working C compiler: /usr/bin/cc</span><br><span class=line>-- Check for working C compiler: /usr/bin/cc -- works</span><br><span class=line>-- Detecting C compiler ABI info</span><br><span class=line>-- Detecting C compiler ABI info - done</span><br><span class=line>-- Detecting C compile features</span><br><span class=line>-- Detecting C compile features - done</span><br><span class=line>-- Check for working CXX compiler: /usr/bin/c++</span><br><span class=line>-- Check for working CXX compiler: /usr/bin/c++ -- works</span><br><span class=line>-- Detecting CXX compiler ABI info</span><br><span class=line>-- Detecting CXX compiler ABI info - done</span><br><span class=line>-- Detecting CXX compile features</span><br><span class=line>-- Detecting CXX compile features - done</span><br><span class=line>-- Configuring done</span><br><span class=line>-- Generating done</span><br><span class=line>-- Build files have been written to: /home/robin/Linux/build</span><br></pre></td></tr></tbody></table><p>现在<code>cmake</code>命令是在<code>build</code>目录中执行的，但是<code>CMakeLists.txt</code>文件是<code>build</code>目录的上一级目录中，所以<code>cmake</code> 命令后指定的路径为<code>..</code>，即当前目录的上一级目录。</p><p>当命令执行完毕之后，在<code>build</code>目录中会生成一个<code>makefile</code>文件</p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre></td><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>tree build -L 1</span></span><br><span class=line>build</span><br><span class=line>├── CMakeCache.txt</span><br><span class=line>├── CMakeFiles</span><br><span class=line>├── cmake_install.cmake</span><br><span class=line>└── Makefile</span><br><span class=line></span><br><span class=line>1 directory, 3 files</span><br></pre></td></tr></tbody></table><p>这样就可以在<code>build</code>目录中执行<code>make</code>命令编译项目，生成的相关文件自然也就被存储到<code>build</code>目录中了。这样通过<code>cmake</code>和<code>make</code>生成的所有文件就全部和项目源文件隔离开了，各回各家，各找各妈。</p><h2 id=22-私人订制><a href=/zh/posts/tech/c/cmake%E5%9F%BA%E7%A1%80/#2-2-%e7%a7%81%e4%ba%ba%e8%ae%a2%e5%88%b6 title="2.2 私人订制"></a>2.2 私人订制<a hidden class=anchor aria-hidden=true href=#22-私人订制>#</a></h2><h3 id=221-定义变量><a href=/zh/posts/tech/c/cmake%E5%9F%BA%E7%A1%80/#2-2-1-%e5%ae%9a%e4%b9%89%e5%8f%98%e9%87%8f title="2.2.1 定义变量"></a>2.2.1 定义变量<a hidden class=anchor aria-hidden=true href=#221-定义变量>#</a></h3><p>在上面的例子中一共提供了5个源文件，假设这五个源文件需要反复被使用，每次都直接将它们的名字写出来确实是很麻烦，此时我们就需要定义一个变量，将文件名对应的字符串存储起来，在cmake里定义变量需要使用<code>set</code>。</p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre></td><td class=code><pre><span class=line><span class=comment># SET 指令的语法是：</span></span><br><span class=line><span class=comment># [] 中的参数为可选项, 如不需要可以不写</span></span><br><span class=line><span class=keyword>SET</span>(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]])</span><br></pre></td></tr></tbody></table><ul><li><code>VAR</code>：变量名</li><li><code>VALUE</code>：变量值</li></ul><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre></td><td class=code><pre><span class=line><span class=comment># 方式1: 各个源文件之间使用空格间隔</span></span><br><span class=line><span class=comment># set(SRC_LIST add.c  div.c   main.c  mult.c  sub.c)</span></span><br><span class=line></span><br><span class=line><span class=comment># 方式2: 各个源文件之间使用分号 ; 间隔</span></span><br><span class=line><span class=keyword>set</span>(SRC_LIST add.c;div.c;main.c;mult.c;sub.c)</span><br><span class=line><span class=keyword>add_executable</span>(app  <span class=variable>${SRC_LIST}</span>)</span><br></pre></td></tr></tbody></table><h3 id=222-指定使用的c标准><a href=/zh/posts/tech/c/cmake%E5%9F%BA%E7%A1%80/#2-2-2-%e6%8c%87%e5%ae%9a%e4%bd%bf%e7%94%a8%e7%9a%84C-%e6%a0%87%e5%87%86 title="2.2.2 指定使用的C++标准"></a>2.2.2 指定使用的C++标准<a hidden class=anchor aria-hidden=true href=#222-指定使用的c标准>#</a></h3><p>在编写C++程序的时候，可能会用到C++11、C++14、C++17、C++20等新特性，那么就需要在编译的时候在编译命令中制定出要使用哪个标准：</p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>g++ *.cpp -std=c++11 -o app</span></span><br></pre></td></tr></tbody></table><p>上面的例子中通过参数<code>-std=c++11</code>指定出要使用c++11标准编译程序，C++标准对应有一宏叫做<code>DCMAKE_CXX_STANDARD</code>。在CMake中想要指定C++标准有两种方式：</p><ol><li><p>在 CMakeLists.txt 中通过 set 命令指定</p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre></td><td class=code><pre><span class=line><span class=comment>#增加-std=c++11</span></span><br><span class=line><span class=keyword>set</span>(CMAKE_CXX_STANDARD <span class=number>11</span>)</span><br><span class=line><span class=comment>#增加-std=c++14</span></span><br><span class=line><span class=keyword>set</span>(CMAKE_CXX_STANDARD <span class=number>14</span>)</span><br><span class=line><span class=comment>#增加-std=c++17</span></span><br><span class=line><span class=keyword>set</span>(CMAKE_CXX_STANDARD <span class=number>17</span>)</span><br></pre></td></tr></tbody></table></li><li><p>在执行 cmake 命令的时候指定出这个宏的值</p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre></td><td class=code><pre><span class=line><span class="meta prompt_">#</span><span class=language-bash>增加-std=c++11</span></span><br><span class=line>cmake CMakeLists.txt文件路径 -DCMAKE_CXX_STANDARD=11</span><br><span class=line><span class="meta prompt_">#</span><span class=language-bash>增加-std=c++14</span></span><br><span class=line>cmake CMakeLists.txt文件路径 -DCMAKE_CXX_STANDARD=14</span><br><span class=line><span class="meta prompt_">#</span><span class=language-bash>增加-std=c++17</span></span><br><span class=line>cmake CMakeLists.txt文件路径 -DCMAKE_CXX_STANDARD=17</span><br></pre></td></tr></tbody></table><p>在上面例子中 CMake 后的路径需要根据实际情况酌情修改。</p></li></ol><h3 id=223-指定输出的路径><a href=/zh/posts/tech/c/cmake%E5%9F%BA%E7%A1%80/#2-2-3-%e6%8c%87%e5%ae%9a%e8%be%93%e5%87%ba%e7%9a%84%e8%b7%af%e5%be%84 title="2.2.3 指定输出的路径"></a>2.2.3 指定输出的路径<a hidden class=anchor aria-hidden=true href=#223-指定输出的路径>#</a></h3><p>在CMake中指定可执行程序输出的路径，也对应一个宏，叫做<code>EXECUTABLE_OUTPUT_PATH</code>，它的值还是通过<code>set</code>命令进行设置:</p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>set</span>(HOME /home/robin/Linux/Sort)</span><br><span class=line><span class=keyword>set</span>(EXECUTABLE_OUTPUT_PATH <span class=variable>${HOME}</span>/bin)</span><br></pre></td></tr></tbody></table><ul><li>第一行：定义一个变量用于存储一个绝对路径</li><li>第二行：将拼接好的路径值设置给<code>EXECUTABLE_OUTPUT_PATH</code>宏<ul><li><strong>如果这个路径中的子目录不存在，会自动生成，无需自己手动创建</strong></li></ul></li></ul><p>由于可执行程序是基于 cmake 命令生成的 makefile 文件然后再执行 make 命令得到的，所以如果此处指定可执行程序生成路径的时候使用的是相对路径 ./xxx/xxx，那么这个路径中的 ./ 对应的就是 makefile 文件所在的那个目录。</p><h2 id=23-搜索文件><a href=/zh/posts/tech/c/cmake%E5%9F%BA%E7%A1%80/#2-3-%e6%90%9c%e7%b4%a2%e6%96%87%e4%bb%b6 title="2.3 搜索文件"></a>2.3 搜索文件<a hidden class=anchor aria-hidden=true href=#23-搜索文件>#</a></h2><p>如果一个项目里边的源文件很多，在编写<code>CMakeLists.txt</code>文件的时候不可能将项目目录的各个文件一一罗列出来，这样太麻烦也不现实。所以，在CMake中为我们提供了搜索文件的命令，可以使用<code>aux_source_directory</code>命令或者<code>file</code>命令。</p><h3 id=231-方式1><a href=/zh/posts/tech/c/cmake%E5%9F%BA%E7%A1%80/#2-3-1-%e6%96%b9%e5%bc%8f1 title="2.3.1 方式1"></a>2.3.1 方式1<a hidden class=anchor aria-hidden=true href=#231-方式1>#</a></h3><p>在 CMake 中使用<code>aux_source_directory</code> 命令可以查找某个路径下的<code>所有源文件</code>，命令格式为：</p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>aux_source_directory</span>(&lt; dir &gt; &lt; variable &gt;)</span><br></pre></td></tr></tbody></table><ul><li><code>dir</code>：要搜索的目录</li><li><code>variable</code>：将从<code>dir</code>目录下搜索到的源文件列表存储到该变量中</li></ul><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>cmake_minimum_required</span>(VERSION <span class=number>3.0</span>)</span><br><span class=line><span class=keyword>project</span>(CALC)</span><br><span class=line><span class=keyword>include_directories</span>(<span class=variable>${PROJECT_SOURCE_DIR}</span>/<span class=keyword>include</span>)</span><br><span class=line><span class=comment># 搜索 src 目录下的源文件</span></span><br><span class=line><span class=keyword>aux_source_directory</span>(<span class=variable>${CMAKE_CURRENT_SOURCE_DIR}</span>/src SRC_LIST)</span><br><span class=line><span class=keyword>add_executable</span>(app  <span class=variable>${SRC_LIST}</span>)</span><br></pre></td></tr></tbody></table><h3 id=232-方式2><a href=/zh/posts/tech/c/cmake%E5%9F%BA%E7%A1%80/#2-3-2-%e6%96%b9%e5%bc%8f2 title="2.3.2 方式2"></a>2.3.2 方式2<a hidden class=anchor aria-hidden=true href=#232-方式2>#</a></h3><p>如果一个项目里边的源文件很多，在编写<code>CMakeLists.txt</code>文件的时候不可能将项目目录的各个文件一一罗列出来，这样太麻烦了。所以，在CMake中为我们提供了搜索文件的命令，他就是<code>file（当然，除了搜索以外通过 file 还可以做其他事情）</code>。</p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>file</span>(GLOB/GLOB_RECURSE 变量名 要搜索的文件路径和文件类型)</span><br></pre></td></tr></tbody></table><ul><li><code>GLOB</code>: 将指定目录下搜索到的满足条件的所有文件名生成一个列表，并将其存储到变量中。</li><li><code>GLOB_RECURSE</code>：递归搜索指定目录，将搜索到的满足条件的文件名生成一个列表，并将其存储到变量中。</li></ul><p><strong>搜索当前目录的src目录下所有的源文件，并存储到变量中</strong></p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>file</span>(GLOB MAIN_SRC <span class=variable>${CMAKE_CURRENT_SOURCE_DIR}</span>/src/*.cpp)</span><br><span class=line><span class=keyword>file</span>(GLOB MAIN_HEAD <span class=variable>${CMAKE_CURRENT_SOURCE_DIR}</span>/<span class=keyword>include</span>/*.h)</span><br></pre></td></tr></tbody></table><ul><li><p>CMAKE_CURRENT_SOURCE_DIR 宏表示当前访问的 CMakeLists.txt 文件所在的路径。</p></li><li><p>关于要搜索的文件路径和类型可加双引号，也可不加:</p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>file</span>(GLOB MAIN_HEAD <span class=string>"${CMAKE_CURRENT_SOURCE_DIR}/src/*.h"</span>)</span><br></pre></td></tr></tbody></table></li></ul><h2 id=24-包含头文件><a href=/zh/posts/tech/c/cmake%E5%9F%BA%E7%A1%80/#2-4-%e5%8c%85%e5%90%ab%e5%a4%b4%e6%96%87%e4%bb%b6 title="2.4 包含头文件"></a>2.4 包含头文件<a hidden class=anchor aria-hidden=true href=#24-包含头文件>#</a></h2><p>在编译项目源文件的时候，很多时候都需要将源文件对应的头文件路径指定出来，这样才能保证在编译过程中编译器能够找到这些头文件，并顺利通过编译。在CMake中设置要包含的目录也很简单，通过一个命令就可以搞定了，他就是<code>include_directories</code>:</p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>include_directories</span>(headpath)</span><br></pre></td></tr></tbody></table><p>举例说明，有源文件若干，其目录结构如下：</p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre></td><td class=code><pre><span class=line>$ tree</span><br><span class=line>.</span><br><span class=line>├── build</span><br><span class=line>├── CMakeLists.txt</span><br><span class=line>├── include</span><br><span class=line>│&nbsp;&nbsp; └── head.h</span><br><span class=line>└── src</span><br><span class=line>    ├── add.cpp</span><br><span class=line>    ├── div.cpp</span><br><span class=line>    ├── main.cpp</span><br><span class=line>    ├── mult.cpp</span><br><span class=line>    └── sub.cpp</span><br><span class=line></span><br><span class=line><span class=number>3</span> directories, <span class=number>7</span> files</span><br></pre></td></tr></tbody></table><p><code>CMakeLists.txt</code>文件内容如下:</p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>cmake_minimum_required</span>(VERSION <span class=number>3.0</span>)</span><br><span class=line><span class=keyword>project</span>(CALC)</span><br><span class=line><span class=keyword>set</span>(CMAKE_CXX_STANDARD <span class=number>11</span>)</span><br><span class=line><span class=keyword>set</span>(HOME /home/robin/Linux/calc)</span><br><span class=line><span class=keyword>set</span>(EXECUTABLE_OUTPUT_PATH <span class=variable>${HOME}</span>/bin/)</span><br><span class=line><span class=keyword>include_directories</span>(<span class=variable>${PROJECT_SOURCE_DIR}</span>/<span class=keyword>include</span>)</span><br><span class=line><span class=keyword>file</span>(GLOB SRC_LIST <span class=variable>${CMAKE_CURRENT_SOURCE_DIR}</span>/src/*.cpp)</span><br><span class=line><span class=keyword>add_executable</span>(app  <span class=variable>${SRC_LIST}</span>)</span><br></pre></td></tr></tbody></table><p>其中，第六行指定就是头文件的路径，<code>PROJECT_SOURCE_DIR</code>宏对应的值就是我们在使用cmake命令时，后面紧跟的目录，一般是工程的根目录。</p><h2 id=25-制作动态库或静态库><a href=/zh/posts/tech/c/cmake%E5%9F%BA%E7%A1%80/#2-5-%e5%88%b6%e4%bd%9c%e5%8a%a8%e6%80%81%e5%ba%93%e6%88%96%e9%9d%99%e6%80%81%e5%ba%93 title="2.5 制作动态库或静态库"></a>2.5 制作动态库或静态库<a hidden class=anchor aria-hidden=true href=#25-制作动态库或静态库>#</a></h2><p>有些时候我们编写的源代码并不需要将他们编译生成可执行程序，而是生成一些静态库或动态库提供给第三方使用，下面来讲解在cmake中生成这两类库文件的方法。</p><h3 id=251-制作静态库><a href=/zh/posts/tech/c/cmake%E5%9F%BA%E7%A1%80/#2-5-1-%e5%88%b6%e4%bd%9c%e9%9d%99%e6%80%81%e5%ba%93 title="2.5.1 制作静态库"></a>2.5.1 制作静态库<a hidden class=anchor aria-hidden=true href=#251-制作静态库>#</a></h3><p>在cmake中，如果要制作静态库，需要使用的命令如下：</p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>add_library</span>(库名称 STATIC 源文件<span class=number>1</span> [源文件<span class=number>2</span>] ...) </span><br></pre></td></tr></tbody></table><p>在Linux中，静态库名字分为三部分：<code>lib</code>+<code>库名字</code>+<code>.a</code>，此处只需要指定出库的名字就可以了，另外两部分在生成该文件的时候会自动填充。</p><p>在Windows中虽然库名和Linux格式不同，但也只需指定出名字即可。</p><p>下面有一个目录，需要将<code>src</code>目录中的源文件编译成静态库，然后再使用：</p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre></td><td class=code><pre><span class=line>.</span><br><span class=line>├── build</span><br><span class=line>├── CMakeLists.txt</span><br><span class=line>├── include           # 头文件目录</span><br><span class=line>│&nbsp;&nbsp; └── head.h</span><br><span class=line>├── main.cpp          # 用于测试的源文件</span><br><span class=line>└── src               # 源文件目录</span><br><span class=line>    ├── add.cpp</span><br><span class=line>    ├── div.cpp</span><br><span class=line>    ├── mult.cpp</span><br><span class=line>    └── sub.cpp</span><br></pre></td></tr></tbody></table><p>根据上面的目录结构，可以这样编写<code>CMakeLists.txt</code>文件:</p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>cmake_minimum_required</span>(VERSION <span class=number>3.0</span>)</span><br><span class=line><span class=keyword>project</span>(CALC)</span><br><span class=line><span class=keyword>include_directories</span>(<span class=variable>${PROJECT_SOURCE_DIR}</span>/<span class=keyword>include</span>)</span><br><span class=line><span class=keyword>file</span>(GLOB SRC_LIST <span class=string>"${CMAKE_CURRENT_SOURCE_DIR}/src/*.cpp"</span>)</span><br><span class=line><span class=keyword>add_library</span>(calc STATIC <span class=variable>${SRC_LIST}</span>)</span><br></pre></td></tr></tbody></table><p>这样最终就会生成对应的静态库文件<code>libcalc.a</code>。</p><h3 id=252-制作动态库><a href=/zh/posts/tech/c/cmake%E5%9F%BA%E7%A1%80/#2-5-2-%e5%88%b6%e4%bd%9c%e5%8a%a8%e6%80%81%e5%ba%93 title="2.5.2 制作动态库"></a>2.5.2 制作动态库<a hidden class=anchor aria-hidden=true href=#252-制作动态库>#</a></h3><p>在cmake中，如果要制作动态库，需要使用的命令如下：</p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>add_library</span>(库名称 SHARED 源文件<span class=number>1</span> [源文件<span class=number>2</span>] ...) </span><br></pre></td></tr></tbody></table><p>在Linux中，动态库名字分为三部分：<code>lib</code>+<code>库名字</code>+<code>.so</code>，此处只需要指定出库的名字就可以了，另外两部分在生成该文件的时候会自动填充。</p><p>在Windows中虽然库名和Linux格式不同，但也只需指定出名字即可。</p><p>根据上面的目录结构，可以这样编写<code>CMakeLists.txt</code>文件:</p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>cmake_minimum_required</span>(VERSION <span class=number>3.0</span>)</span><br><span class=line><span class=keyword>project</span>(CALC)</span><br><span class=line><span class=keyword>include_directories</span>(<span class=variable>${PROJECT_SOURCE_DIR}</span>/<span class=keyword>include</span>)</span><br><span class=line><span class=keyword>file</span>(GLOB SRC_LIST <span class=string>"${CMAKE_CURRENT_SOURCE_DIR}/src/*.cpp"</span>)</span><br><span class=line><span class=keyword>add_library</span>(calc SHARED <span class=variable>${SRC_LIST}</span>)</span><br></pre></td></tr></tbody></table><p>这样最终就会生成对应的动态库文件<code>libcalc.so</code>。</p><h3 id=253-指定输出的路径><a href=/zh/posts/tech/c/cmake%E5%9F%BA%E7%A1%80/#2-5-3-%e6%8c%87%e5%ae%9a%e8%be%93%e5%87%ba%e7%9a%84%e8%b7%af%e5%be%84 title="2.5.3 指定输出的路径"></a>2.5.3 指定输出的路径<a hidden class=anchor aria-hidden=true href=#253-指定输出的路径>#</a></h3><h4 id=方式1---适用于动态库><a href=/zh/posts/tech/c/cmake%E5%9F%BA%E7%A1%80/#%e6%96%b9%e5%bc%8f1-%e9%80%82%e7%94%a8%e4%ba%8e%e5%8a%a8%e6%80%81%e5%ba%93 title="方式1 - 适用于动态库"></a>方式1 - 适用于动态库<a hidden class=anchor aria-hidden=true href=#方式1---适用于动态库>#</a></h4><p>对于生成的库文件来说和可执行程序一样都可以指定输出路径。<code>由于在Linux下生成的动态库默认是有执行权限的</code>，所以可以按照生成可执行程序的方式去指定它生成的目录：</p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>cmake_minimum_required</span>(VERSION <span class=number>3.0</span>)</span><br><span class=line><span class=keyword>project</span>(CALC)</span><br><span class=line><span class=keyword>include_directories</span>(<span class=variable>${PROJECT_SOURCE_DIR}</span>/<span class=keyword>include</span>)</span><br><span class=line><span class=keyword>file</span>(GLOB SRC_LIST <span class=string>"${CMAKE_CURRENT_SOURCE_DIR}/src/*.cpp"</span>)</span><br><span class=line><span class=comment># 设置动态库生成路径</span></span><br><span class=line><span class=keyword>set</span>(EXECUTABLE_OUTPUT_PATH <span class=variable>${PROJECT_SOURCE_DIR}</span>/lib)</span><br><span class=line><span class=keyword>add_library</span>(calc SHARED <span class=variable>${SRC_LIST}</span>)</span><br></pre></td></tr></tbody></table><p>对于这种方式来说，其实就是通过<code>set</code>命令给<code>EXECUTABLE_OUTPUT_PATH</code>宏设置了一个路径，这个路径就是可执行文件生成的路径。</p><h4 id=方式2---都适用><a href=/zh/posts/tech/c/cmake%E5%9F%BA%E7%A1%80/#%e6%96%b9%e5%bc%8f2-%e9%83%bd%e9%80%82%e7%94%a8 title="方式2 - 都适用"></a>方式2 - 都适用<a hidden class=anchor aria-hidden=true href=#方式2---都适用>#</a></h4><p>由于在Linux下生成的静态库默认不具有可执行权限，所以在指定静态库生成的路径的时候就不能使用<code>EXECUTABLE_OUTPUT_PATH</code>宏了，而应该使用<code>LIBRARY_OUTPUT_PATH</code>，这个宏对应静态库文件和动态库文件都适用。</p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>cmake_minimum_required</span>(VERSION <span class=number>3.0</span>)</span><br><span class=line><span class=keyword>project</span>(CALC)</span><br><span class=line><span class=keyword>include_directories</span>(<span class=variable>${PROJECT_SOURCE_DIR}</span>/<span class=keyword>include</span>)</span><br><span class=line><span class=keyword>file</span>(GLOB SRC_LIST <span class=string>"${CMAKE_CURRENT_SOURCE_DIR}/src/*.cpp"</span>)</span><br><span class=line><span class=comment># 设置动态库/静态库生成路径</span></span><br><span class=line><span class=keyword>set</span>(LIBRARY_OUTPUT_PATH <span class=variable>${PROJECT_SOURCE_DIR}</span>/lib)</span><br><span class=line><span class=comment># 生成动态库</span></span><br><span class=line><span class=comment>#add_library(calc SHARED ${SRC_LIST})</span></span><br><span class=line><span class=comment># 生成静态库</span></span><br><span class=line><span class=keyword>add_library</span>(calc STATIC <span class=variable>${SRC_LIST}</span>)</span><br></pre></td></tr></tbody></table><h2 id=26-包含库文件><a href=/zh/posts/tech/c/cmake%E5%9F%BA%E7%A1%80/#2-6-%e5%8c%85%e5%90%ab%e5%ba%93%e6%96%87%e4%bb%b6 title="2.6 包含库文件"></a>2.6 包含库文件<a hidden class=anchor aria-hidden=true href=#26-包含库文件>#</a></h2><p>在编写程序的过程中，可能会用到一些系统提供的动态库或者自己制作出的动态库或者静态库文件，cmake中也为我们提供了相关的加载动态库的命令。</p><h3 id=261-链接静态库><a href=/zh/posts/tech/c/cmake%E5%9F%BA%E7%A1%80/#2-6-1-%e9%93%be%e6%8e%a5%e9%9d%99%e6%80%81%e5%ba%93 title="2.6.1 链接静态库"></a>2.6.1 链接静态库<a hidden class=anchor aria-hidden=true href=#261-链接静态库>#</a></h3><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre></td><td class=code><pre><span class=line>src</span><br><span class=line>├── add.cpp</span><br><span class=line>├── div.cpp</span><br><span class=line>├── main.cpp</span><br><span class=line>├── mult.cpp</span><br><span class=line>└── sub.cpp</span><br></pre></td></tr></tbody></table><p>现在我们把上面<code>src</code>目录中的<code>add.cpp、div.cpp、mult.cpp、sub.cpp</code>编译成一个静态库文件<code>libcalc.a</code>。<a href=https://subingwen.cn/linux/library/#1-1-%E7%94%9F%E6%88%90%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93 title=通过命令制作并使用静态链接库>通过命令制作并使用静态链接库</a></p><p>测试目录结构如下：</p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre></td><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>tree</span> </span><br><span class=line>.</span><br><span class=line>├── build</span><br><span class=line>├── CMakeLists.txt</span><br><span class=line>├── include</span><br><span class=line>│&nbsp;&nbsp; └── head.h</span><br><span class=line>├── lib</span><br><span class=line>│&nbsp;&nbsp; └── libcalc.a     # 制作出的静态库的名字</span><br><span class=line>└── src</span><br><span class=line>    └── main.cpp</span><br><span class=line></span><br><span class=line>4 directories, 4 files</span><br></pre></td></tr></tbody></table><p>在cmake中，链接静态库的命令如下：</p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>link_libraries</span>(&lt;static lib&gt; [&lt;static lib&gt;...])</span><br></pre></td></tr></tbody></table><ul><li><strong>参数1</strong>：指定出要链接的静态库的名字<ul><li>可以是全名 <code>libxxx.a</code></li><li>也可以是掐头（<code>lib</code>）去尾（<code>.a</code>）之后的名字 <code>xxx</code></li></ul></li><li><strong>参数2-N</strong>：要链接的其它静态库的名字</li></ul><p>如果该静态库不是系统提供的（自己制作或者使用第三方提供的静态库）可能出现静态库找不到的情况，此时可以将静态库的路径也指定出来：</p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>link_directories</span>(&lt;lib path&gt;)</span><br></pre></td></tr></tbody></table><p>这样，修改之后的<code>CMakeLists.txt</code>文件内容如下:</p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>cmake_minimum_required</span>(VERSION <span class=number>3.0</span>)</span><br><span class=line><span class=keyword>project</span>(CALC)</span><br><span class=line><span class=comment># 搜索指定目录下源文件</span></span><br><span class=line><span class=keyword>file</span>(GLOB SRC_LIST <span class=variable>${CMAKE_CURRENT_SOURCE_DIR}</span>/src/*.cpp)</span><br><span class=line><span class=comment># 包含头文件路径</span></span><br><span class=line><span class=keyword>include_directories</span>(<span class=variable>${PROJECT_SOURCE_DIR}</span>/<span class=keyword>include</span>)</span><br><span class=line><span class=comment># 包含静态库路径</span></span><br><span class=line><span class=keyword>link_directories</span>(<span class=variable>${PROJECT_SOURCE_DIR}</span>/lib)</span><br><span class=line><span class=comment># 链接静态库</span></span><br><span class=line><span class=keyword>link_libraries</span>(calc)</span><br><span class=line><span class=keyword>add_executable</span>(app <span class=variable>${SRC_LIST}</span>)</span><br></pre></td></tr></tbody></table><p>添加了第8行的代码，就可以根据参数指定的路径找到这个静态库了。</p><h3 id=262-链接动态库><a href=/zh/posts/tech/c/cmake%E5%9F%BA%E7%A1%80/#2-6-2-%e9%93%be%e6%8e%a5%e5%8a%a8%e6%80%81%e5%ba%93 title="2.6.2 链接动态库"></a>2.6.2 链接动态库<a hidden class=anchor aria-hidden=true href=#262-链接动态库>#</a></h3><p>在程序编写过程中，除了在项目中引入静态库，好多时候也会使用一些标准的或者第三方提供的一些动态库，关于动态库的制作、使用以及在内存中的加载方式和静态库都是不同的，在此不再过多赘述，如有疑惑请参考<a href=https://subingwen.cn/linux/library/ title="Linux 静态库和动态库">Linux 静态库和动态库</a></p><p>在<code>cmake</code>中链接动态库的命令如下:</p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>target_link_libraries</span>(</span><br><span class=line>    &lt;<span class=keyword>target</span>&gt; </span><br><span class=line>    &lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;item&gt;... </span><br><span class=line>    [&lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;item&gt;...]...)</span><br></pre></td></tr></tbody></table><ul><li><p><strong>target</strong>：指定要加载动态库的文件的名字</p><ul><li>该文件可能是一个源文件</li><li>该文件可能是一个动态库文件</li><li>该文件可能是一个可执行文件</li></ul></li><li><p><strong>PRIVATE|PUBLIC|INTERFACE</strong>：动态库的访问权限，默认为<code>PUBLIC</code></p><ul><li><p>如果各个动态库之间没有依赖关系，无需做任何设置，三者没有没有区别，一般无需指定，使用默认的 PUBLIC 即可。</p></li><li><p><code>动态库的链接具有传递性</code>，如果动态库 A 链接了动态库B、C，动态库D链接了动态库A，此时动态库D相当于也链接了动态库B、C，并可以使用动态库B、C中定义的方法。</p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>target_link_libraries</span>(A B C)</span><br><span class=line><span class=keyword>target_link_libraries</span>(D A)</span><br></pre></td></tr></tbody></table><ul><li><code>PUBLIC</code>：在public后面的库会被Link到前面的target中，并且里面的符号也会被导出，提供给第三方使用。</li><li><code>PRIVATE</code>：在private后面的库仅被link到前面的target中，并且终结掉，第三方不能感知你调了啥库</li><li><code>INTERFACE</code>：在interface后面引入的库不会被链接到前面的target中，只会导出符号。</li></ul></li></ul></li></ul><h4 id=链接系统动态库><a href=/zh/posts/tech/c/cmake%E5%9F%BA%E7%A1%80/#%e9%93%be%e6%8e%a5%e7%b3%bb%e7%bb%9f%e5%8a%a8%e6%80%81%e5%ba%93 title=链接系统动态库></a>链接系统动态库<a hidden class=anchor aria-hidden=true href=#链接系统动态库>#</a></h4><p>动态库的链接和静态库是完全不同的：</p><ul><li>静态库会在生成可执行程序的链接阶段被打包到可执行程序中，所以可执行程序启动，静态库就被加载到内存中了。</li><li>动态库在生成可执行程序的链接阶段<strong>不会</strong>被打包到可执行程序中，当可执行程序被启动并且调用了动态库中的函数的时候，动态库才会被加载到内存</li></ul><p>因此，在<code>cmake</code>中指定要链接的动态库的时候，<code>应该将命令写到生成了可执行文件之后：</code></p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>cmake_minimum_required</span>(VERSION <span class=number>3.0</span>)</span><br><span class=line><span class=keyword>project</span>(<span class=keyword>TEST</span>)</span><br><span class=line><span class=keyword>file</span>(GLOB SRC_LIST <span class=variable>${CMAKE_CURRENT_SOURCE_DIR}</span>/*.cpp)</span><br><span class=line><span class=comment># 添加并指定最终生成的可执行程序名</span></span><br><span class=line><span class=keyword>add_executable</span>(app <span class=variable>${SRC_LIST}</span>)</span><br><span class=line><span class=comment># 指定可执行程序要链接的动态库名字</span></span><br><span class=line><span class=keyword>target_link_libraries</span>(app pthread)</span><br></pre></td></tr></tbody></table><p>在<code>target_link_libraries(app pthread)</code>中：</p><ul><li><code>app:</code> 对应的是最终生成的可执行程序的名字</li><li><code>pthread</code>：这是可执行程序要加载的动态库，这个库是系统提供的线程库，全名为<code>libpthread.so</code>，在指定的时候一般会掐头（lib）去尾（.so）。</li></ul><h4 id=链接第三方动态库><a href=/zh/posts/tech/c/cmake%E5%9F%BA%E7%A1%80/#%e9%93%be%e6%8e%a5%e7%ac%ac%e4%b8%89%e6%96%b9%e5%8a%a8%e6%80%81%e5%ba%93 title=链接第三方动态库></a>链接第三方动态库<a hidden class=anchor aria-hidden=true href=#链接第三方动态库>#</a></h4><p>现在，自己生成了一个动态库，对应的目录结构如下：</p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre></td><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>tree</span> </span><br><span class=line>.</span><br><span class=line>├── build</span><br><span class=line>├── CMakeLists.txt</span><br><span class=line>├── include</span><br><span class=line>│&nbsp;&nbsp; └── head.h            # 动态库对应的头文件</span><br><span class=line>├── lib</span><br><span class=line>│&nbsp;&nbsp; └── libcalc.so        # 自己制作的动态库文件</span><br><span class=line>└── main.cpp              # 测试用的源文件</span><br><span class=line></span><br><span class=line>3 directories, 4 files</span><br></pre></td></tr></tbody></table><p>假设在测试文件<code>main.cpp</code>中既使用了自己制作的动态库<code>libcalc.so</code>又使用了系统提供的线程库，此时<code>CMakeLists.txt</code>文件可以这样写：</p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>cmake_minimum_required</span>(VERSION <span class=number>3.0</span>)</span><br><span class=line><span class=keyword>project</span>(<span class=keyword>TEST</span>)</span><br><span class=line><span class=keyword>file</span>(GLOB SRC_LIST <span class=variable>${CMAKE_CURRENT_SOURCE_DIR}</span>/*.cpp)</span><br><span class=line><span class=keyword>include_directories</span>(<span class=variable>${PROJECT_SOURCE_DIR}</span>/<span class=keyword>include</span>)</span><br><span class=line><span class=keyword>add_executable</span>(app <span class=variable>${SRC_LIST}</span>)</span><br><span class=line><span class=keyword>target_link_libraries</span>(app pthread calc)</span><br></pre></td></tr></tbody></table><p>在<strong>第六行</strong>中，<code>pthread、calc</code>都是可执行程序<code>app</code>要链接的动态库的名字。当可执行程序<code>app</code>生成之后并执行该文件，会提示有如下错误信息：</p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre></td><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>./app</span> </span><br><span class=line>./app: error while loading shared libraries: libcalc.so: cannot open shared object file: No such file or directory</span><br></pre></td></tr></tbody></table><p>这是因为可执行程序启动之后，去加载<code>calc</code>这个动态库，但是不知道这个动态库被放到了什么位置<a href=https://subingwen.cn/linux/library/#2-4-1-%E5%BA%93%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86 title=解决动态库无法加载的问题>解决动态库无法加载的问题</a>，所以就加载失败了，在 CMake 中可以在生成可执行程序之前，通过命令指定出要链接的动态库的位置，指定静态库位置使用的也是这个命令：</p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>link_directories</span>(path)</span><br></pre></td></tr></tbody></table><p>所以修改之后的<code>CMakeLists.txt</code>文件应该是这样的：</p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>cmake_minimum_required</span>(VERSION <span class=number>3.0</span>)</span><br><span class=line><span class=keyword>project</span>(<span class=keyword>TEST</span>)</span><br><span class=line><span class=keyword>file</span>(GLOB SRC_LIST <span class=variable>${CMAKE_CURRENT_SOURCE_DIR}</span>/*.cpp)</span><br><span class=line><span class=comment># 指定源文件或者动态库对应的头文件路径</span></span><br><span class=line><span class=keyword>include_directories</span>(<span class=variable>${PROJECT_SOURCE_DIR}</span>/<span class=keyword>include</span>)</span><br><span class=line><span class=comment># 指定要链接的动态库的路径</span></span><br><span class=line><span class=keyword>link_directories</span>(<span class=variable>${PROJECT_SOURCE_DIR}</span>/lib)</span><br><span class=line><span class=comment># 添加并生成一个可执行程序</span></span><br><span class=line><span class=keyword>add_executable</span>(app <span class=variable>${SRC_LIST}</span>)</span><br><span class=line><span class=comment># 指定要链接的动态库</span></span><br><span class=line><span class=keyword>target_link_libraries</span>(app pthread calc)</span><br></pre></td></tr></tbody></table><p>通过<code>link_directories</code>指定了动态库的路径之后，在执行生成的可执行程序的时候，就不会出现找不到动态库的问题了。</p><p>温馨提示：使用 target_link_libraries 命令就可以链接动态库，也可以链接静态库文件。</p><h2 id=27-日志><a href=/zh/posts/tech/c/cmake%E5%9F%BA%E7%A1%80/#2-7-%e6%97%a5%e5%bf%97 title="2.7 日志"></a>2.7 日志<a hidden class=anchor aria-hidden=true href=#27-日志>#</a></h2><p>在CMake中可以用用户显示一条消息，该命令的名字为<code>message</code>：</p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>message</span>([STATUS|WARNING|AUTHOR_WARNING|FATAL_ERROR|SEND_ERROR] <span class=string>"message to display"</span> ...)</span><br></pre></td></tr></tbody></table><ul><li><code>(无)</code> ：重要消息</li><li><code>STATUS</code> ：非重要消息</li><li><code>WARNING</code>：CMake 警告, 会继续执行</li><li><code>AUTHOR_WARNING</code>：CMake 警告 (dev), 会继续执行</li><li><code>SEND_ERROR</code>：CMake 错误, 继续执行，但是会跳过生成的步骤</li><li><code>FATAL_ERROR</code>：CMake 错误, 终止所有处理过程</li></ul><p>CMake的命令行工具会在stdout上显示<code>STATUS</code>消息，在stderr上显示其他所有消息。CMake的GUI会在它的log区域显示所有消息。</p><p>CMake警告和错误消息的文本显示使用的是一种简单的标记语言。文本没有缩进，超过长度的行会回卷，段落之间以新行做为分隔符。</p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre></td><td class=code><pre><span class=line><span class=comment># 输出一般日志信息</span></span><br><span class=line><span class=keyword>message</span>(STATUS <span class=string>"source path: ${PROJECT_SOURCE_DIR}"</span>)</span><br><span class=line><span class=comment># 输出警告信息</span></span><br><span class=line><span class=keyword>message</span>(WARNING <span class=string>"source path: ${PROJECT_SOURCE_DIR}"</span>)</span><br><span class=line><span class=comment># 输出错误信息</span></span><br><span class=line><span class=keyword>message</span>(FATAL_ERROR <span class=string>"source path: ${PROJECT_SOURCE_DIR}"</span>)</span><br></pre></td></tr></tbody></table><h2 id=28-变量操作><a href=/zh/posts/tech/c/cmake%E5%9F%BA%E7%A1%80/#2-8-%e5%8f%98%e9%87%8f%e6%93%8d%e4%bd%9c title="2.8 变量操作"></a>2.8 变量操作<a hidden class=anchor aria-hidden=true href=#28-变量操作>#</a></h2><h3 id=281-追加><a href=/zh/posts/tech/c/cmake%E5%9F%BA%E7%A1%80/#2-8-1-%e8%bf%bd%e5%8a%a0 title="2.8.1 追加"></a>2.8.1 追加<a hidden class=anchor aria-hidden=true href=#281-追加>#</a></h3><p>有时候项目中的源文件并不一定都在同一个目录中，但是这些源文件最终却需要一起进行编译来生成最终的可执行文件或者库文件。如果我们通过<code>file</code>命令对各个目录下的源文件进行搜索，最后还需要做一个字符串拼接的操作，关于字符串拼接可以使用<code>set</code>命令也可以使用<code>list</code>命令。</p><h4 id=使用set拼接><a href=/zh/posts/tech/c/cmake%E5%9F%BA%E7%A1%80/#%e4%bd%bf%e7%94%a8set%e6%8b%bc%e6%8e%a5 title=使用set拼接></a>使用set拼接<a hidden class=anchor aria-hidden=true href=#使用set拼接>#</a></h4><p>如果使用set进行字符串拼接，对应的命令格式如下：</p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>set</span>(变量名<span class=number>1</span> <span class=variable>${变量名1}</span> <span class=variable>${变量名2}</span> ...)</span><br></pre></td></tr></tbody></table><p>关于上面的命令其实就是将从第二个参数开始往后所有的字符串进行拼接，最后将结果存储到第一个参数中，如果第一个参数中原来有数据会对原数据就行覆盖。</p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>cmake_minimum_required</span>(VERSION <span class=number>3.0</span>)</span><br><span class=line><span class=keyword>project</span>(<span class=keyword>TEST</span>)</span><br><span class=line><span class=keyword>set</span>(TEMP <span class=string>"hello,world"</span>)</span><br><span class=line><span class=keyword>file</span>(GLOB SRC_1 <span class=variable>${PROJECT_SOURCE_DIR}</span>/src1/*.cpp)</span><br><span class=line><span class=keyword>file</span>(GLOB SRC_2 <span class=variable>${PROJECT_SOURCE_DIR}</span>/src2/*.cpp)</span><br><span class=line><span class=comment># 追加(拼接)</span></span><br><span class=line><span class=keyword>set</span>(SRC_1 <span class=variable>${SRC_1}</span> <span class=variable>${SRC_2}</span> <span class=variable>${TEMP}</span>)</span><br><span class=line><span class=keyword>message</span>(STATUS <span class=string>"message: ${SRC_1}"</span>)</span><br></pre></td></tr></tbody></table><h4 id=使用list拼接><a href=/zh/posts/tech/c/cmake%E5%9F%BA%E7%A1%80/#%e4%bd%bf%e7%94%a8list%e6%8b%bc%e6%8e%a5 title=使用list拼接></a>使用list拼接<a hidden class=anchor aria-hidden=true href=#使用list拼接>#</a></h4><p>如果使用list进行字符串拼接，对应的命令格式如下：</p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>list</span>(APPEND &lt;<span class=keyword>list</span>&gt; [&lt;element&gt; ...])</span><br></pre></td></tr></tbody></table><p><code>list</code>命令的功能比<code>set</code>要强大，字符串拼接只是它的其中一个功能，所以需要在它第一个参数的位置指定出我们要做的操作，<code>APPEND</code>表示进行数据追加，后边的参数和<code>set</code>就一样了。</p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>cmake_minimum_required</span>(VERSION <span class=number>3.0</span>)</span><br><span class=line><span class=keyword>project</span>(<span class=keyword>TEST</span>)</span><br><span class=line><span class=keyword>set</span>(TEMP <span class=string>"hello,world"</span>)</span><br><span class=line><span class=keyword>file</span>(GLOB SRC_1 <span class=variable>${PROJECT_SOURCE_DIR}</span>/src1/*.cpp)</span><br><span class=line><span class=keyword>file</span>(GLOB SRC_2 <span class=variable>${PROJECT_SOURCE_DIR}</span>/src2/*.cpp)</span><br><span class=line><span class=comment># 追加(拼接)</span></span><br><span class=line><span class=keyword>list</span>(APPEND SRC_1 <span class=variable>${SRC_1}</span> <span class=variable>${SRC_2}</span> <span class=variable>${TEMP}</span>)</span><br><span class=line><span class=keyword>message</span>(STATUS <span class=string>"message: ${SRC_1}"</span>)</span><br></pre></td></tr></tbody></table><p>在CMake中，使用<code>set</code>命令可以创建一个<code>list</code>。一个在<code>list</code>内部是一个由<code>分号;</code>分割的一组字符串。例如，<code>set(var a b c d e)</code>命令将会创建一个<code>list:a;b;c;d;e</code>，但是最终打印变量值的时候得到的是<code>abcde</code>。</p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>set</span>(tmp1 a;b;c;d;e)</span><br><span class=line><span class=keyword>set</span>(tmp2 a b c d e)</span><br><span class=line><span class=keyword>message</span>(<span class=variable>${tmp1}</span>)</span><br><span class=line><span class=keyword>message</span>(<span class=variable>${tmp2}</span>)</span><br></pre></td></tr></tbody></table><p>输出的结果:</p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre></td><td class=code><pre><span class=line>abcde</span><br><span class=line>abcde</span><br></pre></td></tr></tbody></table><h3 id=282-字符串移除><a href=/zh/posts/tech/c/cmake%E5%9F%BA%E7%A1%80/#2-8-2-%e5%ad%97%e7%ac%a6%e4%b8%b2%e7%a7%bb%e9%99%a4 title="2.8.2 字符串移除"></a>2.8.2 字符串移除<a hidden class=anchor aria-hidden=true href=#282-字符串移除>#</a></h3><p>我们在通过<code>file</code>搜索某个目录就得到了该目录下所有的源文件，但是其中有些源文件并不是我们所需要的，比如：</p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre></td><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>tree</span></span><br><span class=line>.</span><br><span class=line>├── add.cpp</span><br><span class=line>├── div.cpp</span><br><span class=line>├── main.cpp</span><br><span class=line>├── mult.cpp</span><br><span class=line>└── sub.cpp</span><br><span class=line></span><br><span class=line>0 directories, 5 files</span><br></pre></td></tr></tbody></table><p>在当前这么目录有五个源文件，其中<code>main.cpp</code>是一个测试文件。如果我们想要把计算器相关的源文件生成一个动态库给别人使用，那么只需要<code>add.cpp、div.cp、mult.cpp、sub.cpp</code>这四个源文件就可以了。此时，就需要将<code>main.cpp</code>从搜索到的数据中剔除出去，想要实现这个功能，也可以使用<code>list</code></p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>list</span>(REMOVE_ITEM &lt;<span class=keyword>list</span>&gt; &lt;value&gt; [&lt;value&gt; ...])</span><br></pre></td></tr></tbody></table><p>通过上面的命令原型可以看到删除和追加数据类似，只不过是第一个参数变成了<code>REMOVE_ITEM</code>。</p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>cmake_minimum_required</span>(VERSION <span class=number>3.0</span>)</span><br><span class=line><span class=keyword>project</span>(<span class=keyword>TEST</span>)</span><br><span class=line><span class=keyword>set</span>(TEMP <span class=string>"hello,world"</span>)</span><br><span class=line><span class=keyword>file</span>(GLOB SRC_1 <span class=variable>${PROJECT_SOURCE_DIR}</span>/*.cpp)</span><br><span class=line><span class=comment># 移除前日志</span></span><br><span class=line><span class=keyword>message</span>(STATUS <span class=string>"message: ${SRC_1}"</span>)</span><br><span class=line><span class=comment># 移除 main.cpp</span></span><br><span class=line><span class=keyword>list</span>(REMOVE_ITEM SRC_1 <span class=variable>${PROJECT_SOURCE_DIR}</span>/main.cpp)</span><br><span class=line><span class=comment># 移除后日志</span></span><br><span class=line><span class=keyword>message</span>(STATUS <span class=string>"message: ${SRC_1}"</span>)</span><br></pre></td></tr></tbody></table><p>可以看到，在<code>第8行</code>把将要移除的文件的名字指定给<code>list</code>就可以了。但是一定要注意通过 file 命令搜索源文件的时候得到的是文件的绝对路径（在list中每个文件对应的路径都是一个item，并且都是绝对路径），那么在移除的时候也要将该文件的绝对路径指定出来才可以，否是移除操作不会成功。</p><p>关于<code>list</code>命令还有其它功能，但是并不常用，在此就不一一进行举例介绍了。</p><ol><li><p>获取 list 的长度。</p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>list</span>(LENGTH &lt;<span class=keyword>list</span>&gt; &lt;output variable&gt;)</span><br></pre></td></tr></tbody></table><ul><li><code>LENGTH</code>：子命令LENGTH用于读取列表长度</li><li><code>&lt;list></code>：当前操作的列表</li><li><code>&lt;output variable></code>：新创建的变量，用于存储列表的长度。</li></ul></li><li><p>读取列表中指定索引的的元素，可以指定多个索引</p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>list</span>(GET &lt;<span class=keyword>list</span>&gt; &lt;element index&gt; [&lt;element index&gt; ...] &lt;output variable&gt;)</span><br></pre></td></tr></tbody></table><ul><li><code>&lt;list></code>：当前操作的列表</li><li><code>&lt;element index></code>：列表元素的索引<ul><li>从0开始编号，索引0的元素为列表中的第一个元素；</li><li>索引也可以是负数，<code>-1</code>表示列表的最后一个元素，<code>-2</code>表示列表倒数第二个元素，以此类推</li><li>当索引（不管是正还是负）超过列表的长度，运行会报错</li></ul></li><li><code>&lt;output variable></code>：新创建的变量，存储指定索引元素的返回结果，也是一个列表。</li></ul></li><li><p>将列表中的元素用连接符（字符串）连接起来组成一个字符串</p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>list</span> (JOIN &lt;<span class=keyword>list</span>&gt; &lt;glue&gt; &lt;output variable&gt;)</span><br></pre></td></tr></tbody></table><ul><li><code>&lt;list></code>：当前操作的列表</li><li><code>&lt;glue></code>：指定的连接符（字符串）</li><li><code>&lt;output variable></code>：新创建的变量，存储返回的字符串</li></ul></li><li><p>查找列表是否存在指定的元素，若果未找到，返回-1</p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>list</span>(FIND &lt;<span class=keyword>list</span>&gt; &lt;value&gt; &lt;output variable&gt;)</span><br></pre></td></tr></tbody></table><ul><li><code>&lt;list></code>：当前操作的列表</li><li><code>&lt;value></code>：需要再列表中搜索的元素</li><li><code>&lt;output variable></code>：新创建的变量<ul><li>如果列表<code>&lt;list></code>中存在<code>&lt;value></code>，那么返回<code>&lt;value></code>在列表中的索引</li><li>如果未找到则返回-1。</li></ul></li></ul></li><li><p>将元素追加到列表中</p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>list</span> (APPEND &lt;<span class=keyword>list</span>&gt; [&lt;element&gt; ...])</span><br></pre></td></tr></tbody></table></li><li><p>在list中指定的位置插入若干元素</p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>list</span>(INSERT &lt;<span class=keyword>list</span>&gt; &lt;element_index&gt; &lt;element&gt; [&lt;element&gt; ...])</span><br></pre></td></tr></tbody></table></li><li><p>将元素插入到列表的0索引位置</p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>list</span> (PREPEND &lt;<span class=keyword>list</span>&gt; [&lt;element&gt; ...])</span><br></pre></td></tr></tbody></table></li><li><p>将列表中最后元素移除</p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>list</span> (POP_BACK &lt;<span class=keyword>list</span>&gt; [&lt;out-var&gt;...])</span><br></pre></td></tr></tbody></table></li><li><p>将列表中第一个元素移除</p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>list</span> (POP_FRONT &lt;<span class=keyword>list</span>&gt; [&lt;out-var&gt;...])</span><br></pre></td></tr></tbody></table></li><li><p>将指定的元素从列表中移除</p></li></ol><pre><code>&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;list&lt;/span&gt; (REMOVE_ITEM &amp;lt;&lt;span class=&quot;keyword&quot;&gt;list&lt;/span&gt;&amp;gt; &amp;lt;value&amp;gt; [&amp;lt;value&amp;gt; ...])&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
</code></pre><ol start=11><li>将指定索引的元素从列表中移除</li></ol><pre><code>&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;list&lt;/span&gt; (REMOVE_AT &amp;lt;&lt;span class=&quot;keyword&quot;&gt;list&lt;/span&gt;&amp;gt; &amp;lt;index&amp;gt; [&amp;lt;index&amp;gt; ...])&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
</code></pre><ol start=12><li>移除列表中的重复元素</li></ol><pre><code>&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;list&lt;/span&gt; (REMOVE_DUPLICATES &amp;lt;&lt;span class=&quot;keyword&quot;&gt;list&lt;/span&gt;&amp;gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
</code></pre><ol start=13><li>列表翻转</li></ol><pre><code>&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;list&lt;/span&gt;(REVERSE &amp;lt;&lt;span class=&quot;keyword&quot;&gt;list&lt;/span&gt;&amp;gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
</code></pre><ol start=14><li>列表排序</li></ol><pre><code>&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;list&lt;/span&gt; (SORT &amp;lt;&lt;span class=&quot;keyword&quot;&gt;list&lt;/span&gt;&amp;gt; [COMPARE &amp;lt;compare&amp;gt;] [CASE &amp;lt;case&amp;gt;] [ORDER &amp;lt;order&amp;gt;])&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

+   `COMPARE`：指定排序方法。有如下几种值可选：
    +   `STRING`:按照字母顺序进行排序，为默认的排序方法
    +   `FILE_BASENAME`：如果是一系列路径名，会使用basename进行排序
    +   `NATURAL`：使用自然数顺序排序
+   `CASE`：指明是否大小写敏感。有如下几种值可选：
    +   `SENSITIVE`: 按照大小写敏感的方式进行排序，为默认值
    +   `INSENSITIVE`：按照大小写不敏感方式进行排序
+   `ORDER`：指明排序的顺序。有如下几种值可选：
    +   `ASCENDING`:按照升序排列，为默认值
    +   `DESCENDING`：按照降序排列
</code></pre><h2 id=29-宏定义><a href=/zh/posts/tech/c/cmake%E5%9F%BA%E7%A1%80/#2-9-%e5%ae%8f%e5%ae%9a%e4%b9%89 title="2.9 宏定义"></a>2.9 宏定义<a hidden class=anchor aria-hidden=true href=#29-宏定义>#</a></h2><p>在进行程序测试的时候，我们可以在代码中添加一些宏定义，通过这些宏来控制这些代码是否生效，如下所示：</p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre></td><td class=code><pre><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;stdio.h&gt;</span></span></span><br><span class=line><span class=meta>#<span class=keyword>define</span> NUMBER  3</span></span><br><span class=line></span><br><span class=line><span class=function><span class=type>int</span> <span class=title>main</span><span class=params>()</span></span></span><br><span class=line><span class=function></span>{</span><br><span class=line>    <span class=type>int</span> a = <span class=number>10</span>;</span><br><span class=line><span class=meta>#<span class=keyword>ifdef</span> DEBUG</span></span><br><span class=line>    <span class=built_in>printf</span>(<span class=string>"我是一个程序猿, 我不会爬树...\n"</span>);</span><br><span class=line><span class=meta>#<span class=keyword>endif</span></span></span><br><span class=line>    <span class=keyword>for</span>(<span class=type>int</span> i=<span class=number>0</span>; i&lt;NUMBER; ++i)</span><br><span class=line>    {</span><br><span class=line>        <span class=built_in>printf</span>(<span class=string>"hello, GCC!!!\n"</span>);</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>}</span><br></pre></td></tr></tbody></table><p>在程序的第七行对<code>DEBUG</code>宏进行了判断，如果该宏被定义了，那么第八行就会进行日志输出，如果没有定义这个宏，第八行就相当于被注释掉了，因此最终无法看到日志输入出（<strong>上述代码中并没有定义这个宏</strong>）。</p><p>为了让测试更灵活，我们可以不在代码中定义这个宏，而是在测试的时候去把它定义出来，其中一种方式就是在<code>gcc/g++</code>命令中去指定，如下：</p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>gcc test.c -DDEBUG -o app</span></span><br></pre></td></tr></tbody></table><p>在<code>gcc/g++</code>命令中通过参数 <code>-D</code>指定出要定义的宏的名字，这样就相当于在代码中定义了一个宏，其名字为<code>DEBUG</code>。</p><p>在<code>CMake</code>中我们也可以做类似的事情，对应的命令叫做<code>add_definitions</code>:</p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>add_definitions</span>(-D宏名称)</span><br></pre></td></tr></tbody></table><p>针对于上面的源文件编写一个<code>CMakeLists.txt</code>，内容如下：</p><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>cmake_minimum_required</span>(VERSION <span class=number>3.0</span>)</span><br><span class=line><span class=keyword>project</span>(<span class=keyword>TEST</span>)</span><br><span class=line><span class=comment># 自定义 DEBUG 宏</span></span><br><span class=line><span class=keyword>add_definitions</span>(-DDEBUG)</span><br><span class=line><span class=keyword>add_executable</span>(app ./<span class=keyword>test</span>.c)</span><br></pre></td></tr></tbody></table><p>通过这种方式，上述代码中的第八行日志就能够被输出出来了。</p><h2 id=3-预定义宏><a href=/zh/posts/tech/c/cmake%E5%9F%BA%E7%A1%80/#3-%e9%a2%84%e5%ae%9a%e4%b9%89%e5%ae%8f title="3. 预定义宏"></a>3. 预定义宏<a hidden class=anchor aria-hidden=true href=#3-预定义宏>#</a></h2><p>下面的列表中为大家整理了一些<code>CMake</code>中常用的宏：</p><table><thead><tr><th>宏</th><th>功能</th></tr></thead><tbody><tr><td>PROJECT_SOURCE_DIR</td><td>使用cmake命令后紧跟的目录，一般是工程的根目录</td></tr><tr><td>PROJECT_BINARY_DIR</td><td>执行cmake命令的目录</td></tr><tr><td>CMAKE_CURRENT_SOURCE_DIR</td><td>当前处理的CMakeLists.txt所在的路径</td></tr><tr><td>CMAKE_CURRENT_BINARY_DIR</td><td>target 编译目录</td></tr><tr><td>EXECUTABLE_OUTPUT_PATH</td><td>重新定义目标二进制可执行文件的存放位置</td></tr><tr><td>LIBRARY_OUTPUT_PATH</td><td>重新定义目标链接库文件的存放位置</td></tr><tr><td>PROJECT_NAME</td><td>返回通过PROJECT指令定义的项目名称</td></tr><tr><td>CMAKE_BINARY_DIR</td><td>项目实际构建路径，假设在<code>build</code>目录进行的构建，那么得到的就是这个目录的路径</td></tr></tbody></table></div><footer class=post-footer><ul class=post-tags><li><a href=https://Kyle-Derrick.github.io/zh/tags/c/>C</a></li><li><a href=https://Kyle-Derrick.github.io/zh/tags/cmake/>CMake</a></li></ul><nav class=paginav><a class=prev href=https://Kyle-Derrick.github.io/zh/posts/tech/open_source_component/redis/redis%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/><span class=title>« 上一页</span><br><span>Redis基本命令</span>
</a><a class=next href=https://Kyle-Derrick.github.io/zh/posts/tech/c/linux_c_01_%E5%9F%BA%E7%A1%80/><span class=title>下一页 »</span><br><span>Linuc C 基础 (01)</span></a></nav></footer><script src=https://giscus.app/client.js data-repo=Kyle-Derrick/Kyle-Derrick.github.io data-repo-id=R_kgDOOqQLVA data-category=Announcements data-category-id=DIC_kwDOOqQLVM4CtPKE data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=zh-CN crossorigin=anonymous async></script></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>